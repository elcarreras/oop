# Экзамен ООП

## 1. Понятие объектно-ориентированного программирования (ООП). Основные принципы ООП. Наследование, агрегация, композиция. Примеры реализации принципов ООП в ЯП C#.
**ООП** - это парадигма программирования, основанная на объектах, которые объединяют данные (поля, свойства) и поведение (методы).

### **4 основынх принципа ООП:**
1)	**Абстракция** – упрощение сложной системы путем выделения наиболее важных характеристик и игнорирования второстепенных. В ООП абстракция реализуется через создание классов, которые представляют собой обобщенные модели объектов.
```C#
// Абстракция (интерфейс)
public interface IShape {
    double GetArea();  // Абстрактный метод
}
```

2) **Инкапсуляция** – скрытие внутренней реализации объекта и предоставления безопасного интерфейса для работы с ним. 
2)	**Наследование** – возможность создать новый класс на основе существующих с повторным использованием кода
работы с ним. 
```C#
// Инкапсуляция и наследование
public class Rectangle : IShape {
    private double _width;  // Инкапсуляция (private поле)
    private double _height;

    public Rectangle(double width, double height) {
        _width = width;
        _height = height;
    }
    
    // Реализация интерфейса
    public double GetArea() => _width * _height;  
}
```
3)	**Полиморфизм** – возможность объектов  одинаковым интерфейсом иметь разную реализацию 
```C#
// Полиморфизм (разные реализации одного интерфейса)
public class Circle : IShape {
    private double _radius;

    public Circle(double radius) => _radius = radius;

    public double GetArea() => Math.PI * _radius * _radius;
}
```
Использование кода принципов ООП вместе:
```C#
// Использование
var canvas = new Canvas();
canvas.AddShape(new Rectangle(10, 20));  // Полиморфизм
canvas.AddShape(new Circle(5));

foreach (var shape in canvas.Shapes) {
    Console.WriteLine($"Area: {shape.GetArea()}");
}
```


### **Наследование, агрегация и композиция:**

1) **Наследование** - класс-наследник (подкласс) получает все поля и методы родительского класса.
```C#
public class Animal {
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal {  // Наследование
    public void Bark() => Console.WriteLine("Barking...");
}

var dog = new Dog();
dog.Eat();  // Метод родителя
dog.Bark(); // Свой метод
```
2) **Агрегация** - Объект содержит другой объект, но они могут существовать независимо.
```C#
public class Engine { }  // Двигатель может быть без машины

public class Car {
    private Engine _engine;
    
    // Двигатель передается извне
    public Car(Engine engine) {
        _engine = engine;
    }
}

var engine = new Engine();
var car = new Car(engine);  // Машина использует существующий двигатель
```
3) **Композиция** - Объект владеет другим объектом, и зависимый объект не существует без основного.
```C#
public class Heart { }  // Сердце не существует без тела

public class Human {
    private Heart _heart;
    
    // Сердце создается при создании человека
    public Human() {
        _heart = new Heart();  // Композиция
    }
}

var human = new Human();  // Сердце создается автоматически
```

## 2. Понятие класса. Основные элементы классов. Отличия класса и объекта.

**Класс** — это шаблон или описание для создания объектов в ООП. Он определяет:

* **данные (поля, свойства)** — характеристики объекта
* **поведение (методы)** — действия, которые объект может выполнять.
* **правила доступа** (модификаторы `private`, `public` и др.).

Класс описывает **абстрактную сущность**, например, `Car`, `Person`, `Student`, а объект — это **конкретный экземпляр** этого класса (например, `myCar`, `johnDoe`).

**Основные элементы класса:**
* Поля
* Методы

**Пример класса:**
```C#
public class Person 
{
    // Поля (данные)
    private string _name;
    private int _age;

    // Конструктор (инициализация объекта)
    public Person(string name, int age) 
    {
        _name = name;
        _age = age;
    }

    // Метод (поведение)
    public void Greet() 
    {
        Console.WriteLine($"Привет, меня зовут {_name} и мне {_age} лет.");
    }
}
```
**Итог:**
* **Класс** — это шаблон с описанием структуры и поведения.
* **Объект** — конкретная "реализация" класса, созданная через `new`.
* **Основные элементы класса**: поля, методы.

## 3. Ссылочные и значимые типы данных. Примеры, объявление и инициализация переменных. Приведение ссылочных и значимых типов данных. Понтие nullable типов данных

### Ссылочные и значимые типы данных.

**Значимые типы (Value Types)**:
* Хранят непосредственно значение в стеке (stack).
* Копируются по значению (при присваивании создается копия).
* Примеры:
  * Простые типы: `int`, `float`, `double`, `bool`, `char`, `struct`, `enum`.
  * Особый случай: `decimal` (хранится как структура).

**Ссылочные типы (Reference Types)**:
* Хранят ссылку на объект в куче (heap), а сам объект — в управляемой памяти.
* Копируются по ссылке (при присваивании копируется только ссылка).
* Примеры:
  * `class`, `interface`, `string`, `object`, `dynamic`, массивы (`int[]`).
  
**Stack (стек)**
* Что хранится:
  * Значимые типы (`int`, `bool`, `struct`, `enum`).
  * Ссылки на объекты в куче (адреса).
* Особенности:
  * Быстрый доступ (как LIFO-буфер).
  * Автоматическое управление памятью (освобождается при выходе из метода).
  * Ограниченный размер (переполнение → StackOverflowException).

**Heap (куча)**
* Что хранится:
  * Объекты ссылочных типов (`class`, `string`, `массивы`)
* Особенности:
  * Динамическое выделение памяти.
  * Управляется Garbage Collector (GC) (автоматически удаляет неиспользуемые объекты).
  * Медленнее стека (из-за сложности управления).

### Примеры объявления и инициализации

**Значимые типы**
```C#
int number = 10;                  // Инициализация числа
bool isActive = true;             // Логический тип
char letter = 'A';                // Символ
DateTime date = DateTime.Now;     // Структура (значимый тип)s
```

**Ссылочные типы**
```C#
string name = "Alice";            // Строка (ссылочный)
int[] numbers = { 1, 2, 3 };      // Массив
object obj = new object();        // Базовый класс
List<int> list = new List<int>(); // Коллекция
```

### Приведение ссылочных и значимых типов данных

**Явное и неявное приведение**
```C#
// Неявное (автоматическое)
int a = 10;
double b = a;  // int → double (без потерь)

// Явное (ручное)
double c = 10.5;
int d = (int)c;  // double → int (дробная часть отбрасывается)

```

**Приведение ссылочных типов**
* Upcasting (Восходящее приведение) - преобразование производного класса к базовому (например, `Dog` → `Animal`).
  *  ✅ Безопасное (компилятор всегда разрешает).
  *  ✅ Не требует явного приведения (можно без (тип)).
  *  ✅ Происходит автоматически при присваивании.

```C#
class Animal { }
class Dog : Animal { }

Dog dog = new Dog();
Animal animal = dog;  // Upcasting (Dog → Animal)
```

* Downcasting (Нисходящее приведение) - преобразование базового класса к производному (например, Animal → Dog).
  * ⚠ Опасное (может вызвать `InvalidCastException`)
  * ⚠ Требует явного приведения (нужен оператор `(тип)`)
  * ⚠ Требует проверки (через `is`, `as` или `pattern matching`).
  
```C#
// Опасный способ
Animal animal = new Dog();
Dog dog = (Dog)animal;  // Явное приведение (работает, т.к. animal на самом деле Dog)

// Ошибка (InvalidCastException)
Animal animal = new Animal();
Dog dog = (Dog)animal;  // Ошибка! animal не является Dog
```

```C#
// Безопасные способы Downcasting
// Оператор is (проверка типа)
if (animal is Dog) 
{
    Dog dog = (Dog)animal;
    // или через pattern matching:
    if (animal is Dog dog) { ... }
}

// Оператор as (приведение с null)
Dog dog = animal as Dog;  // Если не получится — вернет null
if (dog != null) 
{
    // Приведение успешно
}

// Pattern Matching (C# 7.0+)
if (animal is Dog dog) 
{
    // dog уже приведен к типу Dog
    dog.Bark();
}
```


### Nullable-типы
**Nullable-типы** позволяют значимым типам (value types) принимать значение `null`, что невозможно в обычных условиях
* Используются, когда переменная может отсутствовать (например, данные из БД, опциональные параметры)
* Обозначаются символом ? или через структуру Nullable<T>.

```C#
int? nullableInt = null;          // Эквивалентно Nullable<int>
bool? isDone = null;              // Nullable<bool>

// Проверка и получение значения
if (nullableInt.HasValue) {
    int value = nullableInt.Value;  // Безопасное извлечение
}
// Или с оператором ?? (значение по умолчанию)
int result = nullableInt ?? 0;      // Если null, вернет 0
```

## 4. Модификаторы доступа к элементам класса. Конструктор и финализатор. Насаледование конструкторов и финализаторов. Ключевые слова base и this 

### Модификаторы доступа к элементам класса
Модификаторы доступа определяют видимость членов класса (полей, методов, свойств) для других частей программы.


| Модификатор | Доступность |
|---|---|
| `public` | Доступен всем (из любого кода). |
| `private` | Только внутри класса (по умолчанию для полей). |
| `protected` | Класс + наследники. |
| `internal` | Доступен в пределах сборки (проекта). |
| `protected internal` | Класс + наследники + вся сборка. |
| `private protected` | Только внутри класса и наследников в той же сборке. | 

### Конструктор и финализатор

**Конструктор:**
* Специальный метод, вызываемый при создании объекта (new).
* Имя совпадает с именем класса.
* Не имеет возвращаемого типа.

```C#
class Car 
{
    public string Model { get; }
    
    // Конструктор по умолчанию (если не указан)
    public Car() { Model = "Unknown"; }  
    
    // Параметризированный конструктор
    public Car(string model) => Model = model;
}

var car1 = new Car();         // Model = "Unknown"
var car2 = new Car("Tesla");  // Model = "Tesla"
```
**Финализатор:**
* Аналог деструктора в C++.
* Вызывается сборщиком мусора (GC) перед удалением объекта.
* Нельзя вызывать вручную.

```C#
class ResourceHolder 
{
    ~ResourceHolder()  // Финализатор
    {
        Console.WriteLine("Финализатор вызван!");
    }
}
```

### Наследование конструкторов и финализаторов

* **Наследование конструкторов**
  * Конструкторы **не наследуются**, но можно вызывать конструктор родителя через `base`. 
  * Если базовый класс не имеет конструктора по умолчанию, производный класс **обязан** вызвать один из его конструкторов.

```C#
class Animal 
{
    public string Name { get; }
    public Animal(string name) => Name = name;
}

class Dog : Animal 
{
    public int Age { get; }
    
    // Вызов конструктора Animal через base
    public Dog(string name, int age) : base(name) 
    {
        Age = age;
    }
}

var dog = new Dog("Rex", 3);  // Name = "Rex", Age = 3
```

**Наследование финализаторов:**
* Финализаторы не наследуются, но GC автоматически вызывает цепочку финализаторов (от потомка к родителю).

### Ключевые слова `base` и `this`

**`base`:**
* Обращение к членам базового класса.
* Используется для:
  * Вызова конструктора родителя (`base()`).
  * Доступа к переопределенным методам/свойствам (`base.Method()`).

```C#
class Animal 
{
    public virtual void Eat() => Console.WriteLine("Animal eats");
}

class Dog : Animal 
{
    public override void Eat() 
    {
        base.Eat();                 // Вызов метода родителя
        Console.WriteLine("Dog eats meat");
    }
}
```


**`this`:**
* Обращение к текущему экземпляру класса.
* Используется для:
  * Устранения неоднозначности (если параметр метода совпадает с полем).
  * Вызова другого конструктора в том же классе (`this()`).

```C#
class Person 
{
    private string _name;
    
    public Person() : this("Unknown") { }  // Вызов другого конструктора
    
    public Person(string name) 
    {
        _name = name;  // Можно без this, но так понятнее:
        this._name = name;
    }
}
```

## 5. Использование ключевого слова static. Что означает модификатор static при применении к классу, полу/свойству, конструктору/финализатору. Где в памяти располагаются статические поля? 

Модификатор `static` означает, что член класса (поле, метод, свойство и т. д.) **принадлежит самому классу**, а не его экземплярам. Это позволяет использовать его без создания объекта.

### Применение static к разным элементам
1. **Статический класс (static class)**
   * Нельзя создать экземпляр (new запрещен).
   * Содержит только статические члены.
   * Используется для утилитарных функций (например, `Math`, `Console`).
```C#
public static class MathUtils 
{
    public static double Pi => 3.14159;
    public static int Add(int a, int b) => a + b;
}

// Использование без создания объекта
double pi = MathUtils.Pi;
int sum = MathUtils.Add(5, 3);
```
2. **Статическое поле/свойство (static field/property)**
   * Общее для всех экземпляров класса (хранится в одном месте памяти).
   * Инициализируется при первом обращении или в статическом конструкторе.
```C#
public class Counter 
{
    public static int TotalCount { get; private set; }  // Статическое свойство
    public int InstanceCount { get; set; }              // Обычное свойство

    public Counter() 
    {
        TotalCount++;  // Увеличиваем общий счетчик при создании объекта
        InstanceCount = 1;
    }
}

var c1 = new Counter();  // TotalCount = 1
var c2 = new Counter();  // TotalCount = 2
Console.WriteLine(Counter.TotalCount);  // 2 (доступ через класс)
```
3. **Статический метод (`static method`)**
   * Вызывается без создания объекта.

   * Не может обращаться к нестатическим полям/методам (только к статическим).
```C#
public class Logger 
{
    public static void Log(string message) 
    {
        Console.WriteLine($"[LOG] {DateTime.Now}: {message}");
    }
}

Logger.Log("Hello!");  // Вызов без new Logger()
```

4. **Статический конструктор (`static constructor`)**
   * Вызывается автоматически перед первым использованием класса.
   * Не имеет модификаторов доступа и параметров
   * Используется для инициализации статических полей.
```C#
public class Config 
{
    public static string AppName { get; }

    static Config() 
    {
        AppName = "MyApp";
        Console.WriteLine("Статический конструктор вызван!");
    }
}

// При первом обращении к Config сработает статический конструктор
Console.WriteLine(Config.AppName);  // "MyApp"
```
5. **Cтатический финализатор**
   * В C# **не существует** статических финализаторов.
   * Финализаторы (деструкторы) всегда связаны с экземплярами класса.

### Где в памяти располагаются статические поля? 
* Статические поля хранятся в **специальной области памяти** — High Frequency Heap (часть кучи, управляемой CLR).
* Отличия от обычных полей:

|**Характеристика**|**Обычные поля**|**Статические поля**|
|---|---|---|
|**Память**|В куче (heap) для каждого объекта|В High Frequency Heap|
|**Время жизни**|Удаляются при сборке мусора (GC)|Существуют до завершения программы|
|**Доступ**|Через экземпляр (`obj.Field`)|Через класс (`Class.Field`)|

### Когда использовать static?
* ✅ Для общих ресурсов (например, кэш, конфигурация).
* ✅ Для утилитарных методов (например, Math.Sqrt).
* ✅ Для реализации паттернов (Singleton, Factory).
### Когда НЕ использовать static?
* ❌ Если состояние должно быть уникальным для каждого объекта.
* ❌ Для полей, которые могут изменяться в многопоточной среде (без синхронизации).

## 6. Испоьзование ThreadStatic / AsyncLocal. Взаимодействие static с потоками

[[[[[[[[[ Пока пропущено ]]]]]]]]]


## 7. Использование абстрактных классов и методов. Инициализация переменных типа абстрактного класса, создание объектов абстрактного класса. Наследование абстрактных классов. Отличие от виртуальных методов и обычных методов

Абстрактные классы и методы используются для создания **базового шаблона**, который **нельзя использовать напрямую**, но **можно наследовать и реализовывать** в производных классах.

### Абстрактный класс (abstract class)
* Нельзя создать экземпляр (new запрещен).
* Может содержать:
  * Абстрактные методы (без реализации).
  * Обычные методы (с реализацией).
  * Поля, свойства, конструкторы.

**Пример:**
```C#
public abstract class Animal 
{
    public string Name { get; set; }  // Обычное свойство
    
    public abstract void MakeSound();  // Абстрактный метод (без реализации, должен быть реализован наследником)
    
    public void Eat()                 // Обычный метод (с реализацией)
    {
        Console.WriteLine($"{Name} ест.");
    }
}
```

### Абстрактный метод (abstract method)
* Не имеет тела (только сигнатура).
* Должен быть переопределен в производном классе (кроме abstract class).

**Пример:**
```C#
// Наследуем из предыдущего примера 
public class Dog : Animal 
{
    public override void MakeSound()  // Обязательная реализация
    {
        Console.WriteLine("Гав!");
    }
}
```

### Инициализация переменных типа абстрактного класса
* Хотя нельзя создать объект абстрактного класса, можно:    
  * Создать переменную этого типа.
  * Присвоить ей экземпляр конкретного (не абстрактного) наследника.

**Пример:**
```C#
Animal animal = new Dog { Name = "Рекс" };  // OK: Dog — не абстрактный
animal.MakeSound();  // Гав!
animal.Eat();        // Рекс ест.
```

### Наследование абстрактных классов
* Абстрактный класс может наследовать другой абстрактный класс.
* Если класс-наследник не реализует все абстрактные методы, он тоже должен быть `abstract`
```C#
public abstract class Mammal : Animal 
{
    public abstract void Run();  // Новый абстрактный метод
}

public class Cat : Mammal 
{
    public override void MakeSound() => Console.WriteLine("Мяу!");
    public override void Run() => Console.WriteLine("Бежит!");
}
```

### Отличие абстрактного от виртуальных методов и обычных **методов**

**Виртуальный метод (`virtual`)** — это метод в базовом классе, который:
* Имеет реализацию (тело метода).
* Может быть переопределен в производных классах (с помощью `override`).
* Не является обязательным для переопределения (в отличие от `abstract`).

|Характеристика|Обычный метод|Виртуальный метод|Абстрактный метод|
|---|---|---|---|
|Реализация|Есть (тело метода)|Есть (можно переопределить)|Нет (только сигнатура)|
|Переопределение|❌ Нет|✅ Да (`override`)|✅ Да (`override`)
|Где используется|Любой класс|Любой класс|	Только в `abstract class`|
|Обязательность|Не требует переопределения|Не требует переопределения|Требует в неабстрактном наследнике


### Ключевые отличия абстрактных **классов** от **интерфейсов**
**Интерфейс (`interface`)** — это контракт, который определяет какие методы, свойства и события должен реализовать класс или структура. Он описывает что должно быть сделано, но не как это реализовано.

|Критерий|Абстрактный класс|Интерфейс 
|---|---|---|
|Реализация|Может содержать код|Только сигнатуры методов
|Наследование|Одиночное (`class A : B`)|Множественное (`class A : I1, I2`)
|Поля/Свойства|Могут быть|Только `auto-properties` (C# 8+) (хз че это)
|Конструкторы|Могут быть|Не могут``


### Итог
* **Абстрактный класс** — это "недоделанный" класс, требующий реализации в наследниках.

* **Абстрактный метод** — метод без реализации, который обязан быть переопределен.
