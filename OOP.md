# Экзамен ООП

## 1. Понятие объектно-ориентированного программирования (ООП). Основные принципы ООП. Наследование, агрегация, композиция. Примеры реализации принципов ООП в ЯП C#.
**ООП** - это парадигма программирования, основанная на объектах, которые объединяют данные (поля, свойства) и поведение (методы).

### **4 основyных принципа ООП:**
1)	**Абстракция** – упрощение сложной системы путем выделения наиболее важных характеристик и игнорирования второстепенных. В ООП абстракция реализуется через создание классов, которые представляют собой обобщенные модели объектов.
```C#
// Абстракция (интерфейс)
public interface IShape {
    double GetArea();  // Абстрактный метод
}
```

2) **Инкапсуляция** – скрытие внутренней реализации объекта и предоставления безопасного интерфейса для работы с ним. 
2)	**Наследование** – возможность создать новый класс на основе существующих с повторным использованием кода
работы с ним. 
```C#
// Инкапсуляция и наследование
public class Rectangle : IShape {
    private double _width;  // Инкапсуляция (private поле)
    private double _height;

    public Rectangle(double width, double height) {
        _width = width;
        _height = height;
    }
    
    // Реализация интерфейса
    public double GetArea() => _width * _height;  
}
```
3)	**Полиморфизм** – возможность объектов  одинаковым интерфейсом иметь разную реализацию 
```C#
// Полиморфизм (разные реализации одного интерфейса)
public class Circle : IShape {
    private double _radius;

    public Circle(double radius) => _radius = radius;

    public double GetArea() => Math.PI * _radius * _radius;
}
```
Использование кода принципов ООП вместе:
```C#
// Использование
var canvas = new Canvas();
canvas.AddShape(new Rectangle(10, 20));  // Полиморфизм
canvas.AddShape(new Circle(5));

foreach (var shape in canvas.Shapes) {
    Console.WriteLine($"Area: {shape.GetArea()}");
}
```


### **Наследование, агрегация и композиция:**

1) **Наследование** - класс-наследник (подкласс) получает все поля и методы родительского класса.
```C#
public class Animal {
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal {  // Наследование
    public void Bark() => Console.WriteLine("Barking...");
}

var dog = new Dog();
dog.Eat();  // Метод родителя
dog.Bark(); // Свой метод
```
2) **Агрегация** - Объект содержит другой объект, но они могут существовать независимо.
```C#
public class Engine { }  // Двигатель может быть без машины

public class Car {
    private Engine _engine;
    
    // Двигатель передается извне
    public Car(Engine engine) {
        _engine = engine;
    }
}

var engine = new Engine();
var car = new Car(engine);  // Машина использует существующий двигатель
```
3) **Композиция** - Объект владеет другим объектом, и зависимый объект не существует без основного.
```C#
public class Heart { }  // Сердце не существует без тела

public class Human {
    private Heart _heart;
    
    // Сердце создается при создании человека
    public Human() {
        _heart = new Heart();  // Композиция
    }
}

var human = new Human();  // Сердце создается автоматически
```

## 2. Понятие класса. Основные элементы классов. Отличия класса и объекта.

**Класс** — это шаблон или описание для создания объектов в ООП. Он определяет:

* **данные (поля, свойства)** — характеристики объекта
* **поведение (методы)** — действия, которые объект может выполнять.
* **правила доступа** (модификаторы `private`, `public` и др.).

Класс описывает **абстрактную сущность**, например, `Car`, `Person`, `Student`, а объект — это **конкретный экземпляр** этого класса (например, `myCar`, `johnDoe`).

**Основные элементы класса:**
* Поля
* Методы

**Пример класса:**
```C#
public class Person 
{
    // Поля (данные)
    private string _name;
    private int _age;

    // Конструктор (инициализация объекта)
    public Person(string name, int age) 
    {
        _name = name;
        _age = age;
    }

    // Метод (поведение)
    public void Greet() 
    {
        Console.WriteLine($"Привет, меня зовут {_name} и мне {_age} лет.");
    }
}
```
**Итог:**
* **Класс** — это шаблон с описанием структуры и поведения.
* **Объект** — конкретная "реализация" класса, созданная через `new`.
* **Основные элементы класса**: поля, методы.

## 3. Ссылочные и значимые типы данных. Примеры, объявление и инициализация переменных. Приведение ссылочных и значимых типов данных. Понтие nullable типов данных

### Ссылочные и значимые типы данных.

**Значимые типы (Value Types)**:
* Хранят непосредственно значение в стеке (stack).
* Копируются по значению (при присваивании создается копия).
* Примеры:
  * Простые типы: `int`, `float`, `double`, `bool`, `char`, `struct`, `enum`.
  * Особый случай: `decimal` (хранится как структура).

**Ссылочные типы (Reference Types)**:
* Хранят ссылку на объект в куче (heap), а сам объект — в управляемой памяти.
* Копируются по ссылке (при присваивании копируется только ссылка).
* Примеры:
  * `class`, `interface`, `string`, `object`, `dynamic`, массивы (`int[]`).
  
**Stack (стек)**
* Что хранится:
  * Значимые типы (`int`, `bool`, `struct`, `enum`).
  * Ссылки на объекты в куче (адреса).
* Особенности:
  * Быстрый доступ (как LIFO-буфер).
  * Автоматическое управление памятью (освобождается при выходе из метода).
  * Ограниченный размер (переполнение → StackOverflowException).

**Heap (куча)**
* Что хранится:
  * Объекты ссылочных типов (`class`, `string`, `массивы`)
* Особенности:
  * Динамическое выделение памяти.
  * Управляется Garbage Collector (GC) (автоматически удаляет неиспользуемые объекты).
  * Медленнее стека (из-за сложности управления).

### Примеры объявления и инициализации

**Значимые типы**
```C#
int number = 10;                  // Инициализация числа
bool isActive = true;             // Логический тип
char letter = 'A';                // Символ
DateTime date = DateTime.Now;     // Структура (значимый тип)s
```

**Ссылочные типы**
```C#
string name = "Alice";            // Строка (ссылочный)
int[] numbers = { 1, 2, 3 };      // Массив
object obj = new object();        // Базовый класс
List<int> list = new List<int>(); // Коллекция
```

### Приведение ссылочных и значимых типов данных

**Явное и неявное приведение**
```C#
// Неявное (автоматическое)
int a = 10;
double b = a;  // int → double (без потерь)

// Явное (ручное)
double c = 10.5;
int d = (int)c;  // double → int (дробная часть отбрасывается)

```

**Приведение ссылочных типов**
* Upcasting (Восходящее приведение) - преобразование производного класса к базовому (например, `Dog` → `Animal`).
  *  ✅ Безопасное (компилятор всегда разрешает).
  *  ✅ Не требует явного приведения (можно без (тип)).
  *  ✅ Происходит автоматически при присваивании.

```C#
class Animal { }
class Dog : Animal { }

Dog dog = new Dog();
Animal animal = dog;  // Upcasting (Dog → Animal)
```

* Downcasting (Нисходящее приведение) - преобразование базового класса к производному (например, Animal → Dog).
  * ⚠ Опасное (может вызвать `InvalidCastException`)
  * ⚠ Требует явного приведения (нужен оператор `(тип)`)
  * ⚠ Требует проверки (через `is`, `as` или `pattern matching`).
  
```C#
// Опасный способ
Animal animal = new Dog();
Dog dog = (Dog)animal;  // Явное приведение (работает, т.к. animal на самом деле Dog)

// Ошибка (InvalidCastException)
Animal animal = new Animal();
Dog dog = (Dog)animal;  // Ошибка! animal не является Dog
```

```C#
// Безопасные способы Downcasting
// Оператор is (проверка типа)
if (animal is Dog) 
{
    Dog dog = (Dog)animal;
    // или через pattern matching:
    if (animal is Dog dog) { ... }
}

// Оператор as (приведение с null)
Dog dog = animal as Dog;  // Если не получится — вернет null
if (dog != null) 
{
    // Приведение успешно
}

// Pattern Matching (C# 7.0+)
if (animal is Dog dog) 
{
    // dog уже приведен к типу Dog
    dog.Bark();
}
```


### Nullable-типы
**Nullable-типы** позволяют значимым типам (value types) принимать значение `null`, что невозможно в обычных условиях
* Используются, когда переменная может отсутствовать (например, данные из БД, опциональные параметры)
* Обозначаются символом ? или через структуру Nullable<T>.

```C#
int? nullableInt = null;          // Эквивалентно Nullable<int>
bool? isDone = null;              // Nullable<bool>

// Проверка и получение значения
if (nullableInt.HasValue) {
    int value = nullableInt.Value;  // Безопасное извлечение
}
// Или с оператором ?? (значение по умолчанию)
int result = nullableInt ?? 0;      // Если null, вернет 0
```

## 4. Модификаторы доступа к элементам класса. Конструктор и финализатор. Насаледование конструкторов и финализаторов. Ключевые слова base и this 

### Модификаторы доступа к элементам класса
Модификаторы доступа определяют видимость членов класса (полей, методов, свойств) для других частей программы.


| Модификатор | Доступность |
|---|---|
| `public` | Доступен всем (из любого кода). |
| `private` | Только внутри класса (по умолчанию для полей). |
| `protected` | Класс + наследники. |
| `internal` | Доступен в пределах сборки (проекта). |
| `protected internal` | Класс + наследники + вся сборка. |
| `private protected` | Только внутри класса и наследников в той же сборке. | 

### Конструктор и финализатор

**Конструктор:**
* Специальный метод, вызываемый при создании объекта (new).
* Имя совпадает с именем класса.
* Не имеет возвращаемого типа.

```C#
class Car 
{
    public string Model { get; }
    
    // Конструктор по умолчанию (если не указан)
    public Car() { Model = "Unknown"; }  
    
    // Параметризированный конструктор
    public Car(string model) => Model = model;
}

var car1 = new Car();         // Model = "Unknown"
var car2 = new Car("Tesla");  // Model = "Tesla"
```
**Финализатор:**
* Аналог деструктора в C++.
* Вызывается сборщиком мусора (GC) перед удалением объекта.
* Нельзя вызывать вручную.

```C#
class ResourceHolder 
{
    `ResourceHolder()  // Финализатор
    {
        Console.WriteLine("Финализатор вызван!");
    }
}
```

### Наследование конструкторов и финализаторов

* **Наследование конструкторов**
  * Конструкторы **не наследуются**, но можно вызывать конструктор родителя через `base`. 
  * Если базовый класс не имеет конструктора по умолчанию, производный класс **обязан** вызвать один из его конструкторов.

```C#
class Animal 
{
    public string Name { get; }
    public Animal(string name) => Name = name;
}

class Dog : Animal 
{
    public int Age { get; }
    
    // Вызов конструктора Animal через base
    public Dog(string name, int age) : base(name) 
    {
        Age = age;
    }
}

var dog = new Dog("Rex", 3);  // Name = "Rex", Age = 3
```

**Наследование финализаторов:**
* Финализаторы не наследуются, но GC автоматически вызывает цепочку финализаторов (от потомка к родителю).

### Ключевые слова `base` и `this`

**`base`:**
* Обращение к членам базового класса.
* Используется для:
  * Вызова конструктора родителя (`base()`).
  * Доступа к переопределенным методам/свойствам (`base.Method()`).

```C#
class Animal 
{
    public virtual void Eat() => Console.WriteLine("Animal eats");
}

class Dog : Animal 
{
    public override void Eat() 
    {
        base.Eat();                 // Вызов метода родителя
        Console.WriteLine("Dog eats meat");
    }
}
```


**`this`:**
* Обращение к текущему экземпляру класса.
* Используется для:
  * Устранения неоднозначности (если параметр метода совпадает с полем).
  * Вызова другого конструктора в том же классе (`this()`).

```C#
class Person 
{
    private string _name;
    
    public Person() : this("Unknown") { }  // Вызов другого конструктора
    
    public Person(string name) 
    {
        _name = name;  // Можно без this, но так понятнее:
        this._name = name;
    }
}
```

## 5. Использование ключевого слова static. Что означает модификатор static при применении к классу, полу/свойству, конструктору/финализатору. Где в памяти располагаются статические поля? 

Модификатор `static` означает, что член класса (поле, метод, свойство и т. д.) **принадлежит самому классу**, а не его экземплярам. Это позволяет использовать его без создания объекта.

### Применение static к разным элементам
1. **Статический класс (static class)**
   * Нельзя создать экземпляр (new запрещен).
   * Содержит только статические члены.
   * Используется для утилитарных функций (например, `Math`, `Console`).
```C#
public static class MathUtils 
{
    public static double Pi => 3.14159;
    public static int Add(int a, int b) => a + b;
}

// Использование без создания объекта
double pi = MathUtils.Pi;
int sum = MathUtils.Add(5, 3);
```
2. **Статическое поле/свойство (static field/property)**
   * Общее для всех экземпляров класса (хранится в одном месте памяти).
   * Инициализируется при первом обращении или в статическом конструкторе.
```C#
public class Counter 
{
    public static int TotalCount { get; private set; }  // Статическое свойство
    public int InstanceCount { get; set; }              // Обычное свойство

    public Counter() 
    {
        TotalCount++;  // Увеличиваем общий счетчик при создании объекта
        InstanceCount = 1;
    }
}

var c1 = new Counter();  // TotalCount = 1
var c2 = new Counter();  // TotalCount = 2
Console.WriteLine(Counter.TotalCount);  // 2 (доступ через класс)
```
3. **Статический метод (`static method`)**
   * Вызывается без создания объекта.

   * Не может обращаться к нестатическим полям/методам (только к статическим).
```C#
public class Logger 
{
    public static void Log(string message) 
    {
        Console.WriteLine($"[LOG] {DateTime.Now}: {message}");
    }
}

Logger.Log("Hello!");  // Вызов без new Logger()
```

4. **Статический конструктор (`static constructor`)**
   * Вызывается автоматически перед первым использованием класса.
   * Не имеет модификаторов доступа и параметров
   * Используется для инициализации статических полей.
```C#
public class Config 
{
    public static string AppName { get; }

    static Config() 
    {
        AppName = "MyApp";
        Console.WriteLine("Статический конструктор вызван!");
    }
}

// При первом обращении к Config сработает статический конструктор
Console.WriteLine(Config.AppName);  // "MyApp"
```
5. **Cтатический финализатор**
   * В C# **не существует** статических финализаторов.
   * Финализаторы (деструкторы) всегда связаны с экземплярами класса.

### Где в памяти располагаются статические поля? 
* Статические поля хранятся в **специальной области памяти** — High Frequency Heap (часть кучи, управляемой CLR).
* Отличия от обычных полей:

|**Характеристика**|**Обычные поля**|**Статические поля**|
|---|---|---|
|**Память**|В куче (heap) для каждого объекта|В High Frequency Heap|
|**Время жизни**|Удаляются при сборке мусора (GC)|Существуют до завершения программы|
|**Доступ**|Через экземпляр (`obj.Field`)|Через класс (`Class.Field`)|

### Когда использовать static?
* ✅ Для общих ресурсов (например, кэш, конфигурация).
* ✅ Для утилитарных методов (например, Math.Sqrt).
* ✅ Для реализации паттернов (Singleton, Factory).
### Когда НЕ использовать static?
* ❌ Если состояние должно быть уникальным для каждого объекта.
* ❌ Для полей, которые могут изменяться в многопоточной среде (без синхронизации).

## 6. Использование ThreadStatic / AsyncLocal. Взаимодействие static с потоками

[[[[[[[[[ Пока пропущено ]]]]]]]]]


## 7. Использование абстрактных классов и методов. Инициализация переменных типа абстрактного класса, создание объектов абстрактного класса. Наследование абстрактных классов. Отличие от виртуальных методов и обычных методов

Абстрактные классы и методы используются для создания **базового шаблона**, который **нельзя использовать напрямую**, но **можно наследовать и реализовывать** в производных классах.

### Абстрактный класс (abstract class)
* Нельзя создать экземпляр (new запрещен).
* Может содержать:
  * Абстрактные методы (без реализации).
  * Обычные методы (с реализацией).
  * Поля, свойства, конструкторы.

**Пример:**
```C#
public abstract class Animal 
{
    public string Name { get; set; }  // Обычное свойство
    
    public abstract void MakeSound();  // Абстрактный метод (без реализации, должен быть реализован наследником)
    
    public void Eat()                 // Обычный метод (с реализацией)
    {
        Console.WriteLine($"{Name} ест.");
    }
}
```

### Абстрактный метод (abstract method)
* Не имеет тела (только сигнатура).
* Должен быть переопределен в производном классе (кроме abstract class).

**Пример:**
```C#
// Наследуем из предыдущего примера 
public class Dog : Animal 
{
    public override void MakeSound()  // Обязательная реализация
    {
        Console.WriteLine("Гав!");
    }
}
```

### Инициализация переменных типа абстрактного класса
* Хотя нельзя создать объект абстрактного класса, можно:    
  * Создать переменную этого типа.
  * Присвоить ей экземпляр конкретного (не абстрактного) наследника.

**Пример:**
```C#
Animal animal = new Dog { Name = "Рекс" };  // OK: Dog — не абстрактный
animal.MakeSound();  // Гав!
animal.Eat();        // Рекс ест.
```

### Наследование абстрактных классов
* Абстрактный класс может наследовать другой абстрактный класс.
* Если класс-наследник не реализует все абстрактные методы, он тоже должен быть `abstract`
```C#
public abstract class Mammal : Animal 
{
    public abstract void Run();  // Новый абстрактный метод
}

public class Cat : Mammal 
{
    public override void MakeSound() => Console.WriteLine("Мяу!");
    public override void Run() => Console.WriteLine("Бежит!");
}
```

### Отличие абстрактного от виртуальных методов и обычных **методов**

**Виртуальный метод (`virtual`)** — это метод в базовом классе, который:
* Имеет реализацию (тело метода).
* Может быть переопределен в производных классах (с помощью `override`).
* Не является обязательным для переопределения (в отличие от `abstract`).

|Характеристика|Обычный метод|Виртуальный метод|Абстрактный метод|
|---|---|---|---|
|Реализация|Есть (тело метода)|Есть (можно переопределить)|Нет (только сигнатура)|
|Переопределение|❌ Нет|✅ Да (`override`)|✅ Да (`override`)
|Где используется|Любой класс|Любой класс|	Только в `abstract class`|
|Обязательность|Не требует переопределения|Не требует переопределения|Требует в неабстрактном наследнике


### Ключевые отличия абстрактных **классов** от **интерфейсов**
**Интерфейс (`interface`)** — это контракт, который определяет какие методы, свойства и события должен реализовать класс или структура. Он описывает что должно быть сделано, но не как это реализовано.

|Критерий|Абстрактный класс|Интерфейс 
|---|---|---|
|Реализация|Может содержать код|Только сигнатуры методов
|Наследование|Одиночное (`class A : B`)|Множественное (`class A : I1, I2`)
|Поля/Свойства|Могут быть|Только `auto-properties` (C# 8+) (хз че это)
|Конструкторы|Могут быть|Не могут``


### Итог
* **Абстрактный класс** — это "недоделанный" класс, требующий реализации в наследниках.

* **Абстрактный метод** — метод без реализации, который обязан быть переопределен.


## 8. Использование виртуальных методов. Переопределение методов и операторов. Отличие от абстрактных методов и обычных методов
**Виртуальные методы (`virtual`)** позволяют изменять поведение методов в производных классах без потери базовой реализации

**Виртуальный метод (`virtual`)** — это метод в базовом классе, который:
* Объявляются в базовом классе с ключевым словом `virtual`.
* Имеет реализацию по умолчанию (тело метода).
* Может быть переопределен в производных классах (с помощью `override`).
* Не является обязательным для переопределения (в отличие от `abstract`).

**Пример:**
```C#
class Animal 
{
    public virtual void MakeSound() 
    {
        Console.WriteLine("Some sound");
    }
}

class Dog : Animal 
{
    public override void MakeSound() 
    {
        Console.WriteLine("Гав!");
    }
}

Animal animal = new Dog();
animal.MakeSound();  // "Гав!" (вызывается переопределенный метод) 
```

### Переопределение методов (`override`)
* Используется для замены реализации виртуального или абстрактного метода.
* Требует, чтобы базовый метод был помечен как `virtual`, `abstract` или `override`.

**Пример с цепочкой наследования:**
```C#
class Animal 
{
    public virtual void MakeSound() 
    {
        Console.WriteLine("Some sound");
    }
}

class Bird : Animal 
{
    public override void MakeSound() 
    {
        Console.WriteLine("Чирик!");
    }
}

class Parrot : Bird 
{
    public override void MakeSound() 
    {
        base.MakeSound();  // Вызов метода родителя ("Чирик!")
        Console.WriteLine("Попка дурак!");
    }
}

var parrot = new Parrot();
parrot.MakeSound();  
// Вывод:
// Чирик!
// Попка дурак!
```

### Переопределение операторов (operator)

C# позволяет переопределять стандартные операторы (`+`, `-`, `==` и др.) для своих классов.

**Пример перегрузки оператора +:**
```C#
class Point 
{
    public int X { get; set; }
    public int Y { get; set; }

    public static Point operator +(Point a, Point b) 
    {
        return new Point { X = a.X + b.X, Y = a.Y + b.Y };
    }
}

var p1 = new Point { X = 1, Y = 2 };
var p2 = new Point { X = 3, Y = 4 };
var result = p1 + p2;  // X=4, Y=6
```
**Какие операторы можно перегружать?**
* Унарные: `+`, `-`, `!`, `++`, `--`
* Бинарные: `+`, `-`, `*`, `/`, `==`, `!=`, `>`, `<` и др.
* Нельзя перегружать: `&&`, `||`, `=`, `.`, ``` ` ```

### Отличие  виртуальных методов от абстрактного метода и обычных **методов**

|Характеристика|Обычный метод|Виртуальный метод|Абстрактный метод|
|---|---|---|---|
|Реализация|Есть (тело метода)|Есть (можно переопределить)|Нет (только сигнатура)|
|Переопределение|❌ Нет|✅ Да (`override`)|✅ Да (`override`)
|Где используется|Любой класс|Любой класс|	Только в `abstract class`|
|Обязательность|Не требует переопределения|Не требует переопределения|Требует в неабстрактном наследнике


## 9. Понятие интерфейсов и их использование. Интерфейсные ссылки. Отличие интерфейсов от абстрактных классов. Понятие ковариантности и контрвариантности интерфейсов. 
### Понятие интерфейсов и их использование
**Интерфейс (   `interface`)** – это контракт, который определяет набор методов, свойств, событий или индексаторов, которые должны быть реализованы в классе. Интерфейс не содержит реализации (до C# 8.0), только сигнатуры.

**Основные особенности:**
* Класс, реализующий интерфейс, обязан предоставить реализацию всех его членов.
* Позволяет достичь множественного наследования (класс может реализовывать несколько интерфейсов).
* Используется для абстрагирования поведения и обеспечения гибкости в проектировании кода.

**Пример:**
```csharp
public interface ILogger {
    void Log(string message);
}

public class ConsoleLogger : ILogger {
    public void Log(string message) => Console.WriteLine(message);
}
```

### Интерфейсные ссылки
**Интерфейсная ссылка** — это переменная, объявленная как тип интерфейса, которая может ссылаться на экземпляр любого класса, реализующего этот интерфейс.
Преимущества:
* Полиморфизм : работа с объектами через общий интерфейс.
* Тестируемость : упрощает замену реализаций (например, заглушки в тестах).

Пример:
```C#
ILogger logger = new ConsoleLogger(); // Интерфейсная ссылка
logger.Log("Hello!");
```

|Критерий |Интерфейсы|Абстрактные классы|
|---|---|---|
Реализация|Не содержат реализации (кроме C# 8.0+).|Могут содержать реализацию методов.
Множественное наследование|Поддерживается (класс реализует несколько интерфейсов).|Не поддерживается (класс наследует только один класс).
Поля| Не могут содержать полей.|Могут содержать поля.
Конструкторы|Не имеют конструкторов.|Имеют конструкторы.
Модификаторы доступа|Все члены неявно `public`.|Могут иметь разные модификаторы.
Цель|Определяют поведение.|Определяют состояние и поведение.

Пример абстрактного класcа:
```c#
public abstract class Animal {
    public abstract void MakeSound();
}
```
### Ковариантность и контрвариантность интерфейсов

Эти механизмы работают с обобщениями (`generics`) и позволяют безопасно преобразовывать типы.

1) Ковариантность (`out`):

    Разрешает использовать **более специфичный тип** , чем указан в интерфейсе. Применяется, когда тип используется **только как возвращаемое значение .**
    
    Пример:
    ```C#
    public interface IEnumerable<out T> {
        IEnumerator<T> GetEnumerator();
    }

    IEnumerable<string> strings = new List<string>();
    IEnumerable<object> objects = strings; // Ковариантность: string → object
    ```

2) Контрвариантность (in):
    
    Разрешает использовать **более общий тип** , чем указан в интерфейсе. Применяется, когда тип используется **только как параметр метода**.

    Пример:

    ```C#
    public interface IComparer<in T> {
        int Compare(T x, T y);
    }

    IComparer<object> comparer = new MyComparer();
    IComparer<string> stringComparer = comparer; // Контрвариантность: object ← string
    ```

Ограничения:
* Работает только с ссылочными типами (не с int, DateTime и т.д.).  
### Итог
* Интерфейсы фокусируются на поведении и поддерживают множественное наследование.
* Абстрактные классы предоставляют реализацию и состояние, но ограничены одиночным наследованием.
* Ковариантность/контрвариантность упрощают работу с обобщениями, обеспечивая гибкость типов.

## 10. Генерация исключений и их обработка. Блоки обработки исключений. Генерация собственных типов исключений. Обработка исключений при многопоточном/асинхронном программировании

### Генерация исключений и их обработка

**Исключения** — это механизм, позволяющий обрабатывать ошибки и нештатные ситуации в программе.

**Генерация исключения: **  
* спользуется ключевое слово `throw`.
* Может быть выброшено как системное исключение (`Exception`), так и пользовательское.

**Пример генерации исключения:**
```C#
if (value < 0)
    throw new ArgumentException("Значение не может быть отрицательным.");
```

### Блоки обработки исключений

Для обработки исключений используются блоки:
* `try` : код, в котором может произойти ошибка.
* `catch` : обработка исключения.
* `finally` : код, выполняющийся всегда (например, освобождение ресурсов).


```C#
try {
    int result = Divide(10, 0);
} catch (DivideByZeroException ex) {
    Console.WriteLine($"Ошибка: {ex.Message}");
} finally {
    Console.WriteLine("Блок finally выполнен.");
}
```

Особенности:
* Фильтры исключений (`when`):

    ```C#
    catch (Exception ex) when (ex.Message.Contains("деление")) {
        Console.WriteLine("Конкретная ошибка деления.");
    }
    ```
* Вложенные блоки
    ```c#
    try {
        // Внешний try
        try { /* Внутренний try */ }
        catch { /* Внутренний catch */ }
    } catch { /* Внешний catch */ }
    ```

### Генерация собственных типов исключений
Для создания пользовательских исключений:
* Наследуйтесь от `Exception` или его подклассов (например, `ArgumentException`).
* Реализуйте обязательные конструкторы:
  * `public MyException() : base()`
  * `public MyException(string message) : base(message)`
  * `public MyException(string message, Exception innerException) : base(message, innerException)`
Пример:

```C#
public class InvalidAgeException : Exception {
    public InvalidAgeException() : base("Некорректный возраст.") {}
    public InvalidAgeException(string message) : base(message) {}
    public InvalidAgeException(string message, Exception inner) : base(message, inner) {}
}

// Использование
if (age < 0)
    throw new InvalidAgeException("Возраст не может быть отрицательным.");
```

### Обработка исключений в многопоточном/асинхронном программировании

**Многопоточность (Thread)**
* Исключения в потоке **не перехватываются** в основном потоке.
* Используйте `try-catch` внутри метода потока:

    ```C#
    Thread thread = new Thread(() => {
        try {
            // Код с возможной ошибкой
        } catch (Exception ex) {
            Console.WriteLine($"Ошибка в потоке: {ex.Message}");
        }
    });
    thread.Start();
    ```

**Задачи (Task)**
* Исключения оборачиваются в `AggregateException`.
* Используйте `await` для автоматического распаковывания:
    ```C#
    try {
        await Task.Run(() => {
            throw new InvalidOperationException("Ошибка задачи.");
        });
    } catch (InvalidOperationException ex) {
        Console.WriteLine($"Ошибка: {ex.Message}");
    }
    ```

**Асинхронный код (async/await)**
* Исключения перебрасываются в точку вызова `await`.
* Пример: 
```C#
async Task MyMethodAsync() {
    throw new IOException("Ошибка ввода-вывода.");
}

try {
    await MyMethodAsync();
} catch (IOException ex) {
    Console.WriteLine($"Ошибка: {ex.Message}");
}
```

**Обработка нескольких исключений**
* Используйте `AggregateException` для работы с несколькими ошибками
* Пример:
```С#
try {
    var task1 = Task.Run(() => throw new Exception("Ошибка 1"));
    var task2 = Task.Run(() => throw new Exception("Ошибка 2"));
    Task.WaitAll(task1, task2);
} catch (AggregateException aex) {
    foreach (var ex in aex.InnerExceptions)
        Console.WriteLine($"Ошибка: {ex.Message}");
}
```


## 11. Обобщенные типы данных. Наследование обобщенных типов данных. Ограничения, накладываемые на использование типов данных в обобщенных типах данных. Отличия от boxing/unboxing

### Обобщенные типы данных (Generics)

**Обобщенные типы** — это шаблоны, позволяющие создавать классы, интерфейсы и методы с параметром типа , который определяется при использовании.

**Преимущества:**
* Типобезопасность : ошибки выявляются на этапе компиляции.
* Производительность : избегается упаковка/распаковка (boxing/unboxing).
* Гибкость : один код работает с разными типами.

**Пример:**
```C#
public class Box<T> {
    private T _value;
    public void Set(T value) => _value = value;
    public T Get() => _value;
}

// Использование:
Box<int> intBox = new Box<int>();
intBox.Set(42);
int number = intBox.Get(); // Без cast
```

### Наследование обобщенных типов
Обобщенные типы могут наследовать как от обобщенных, так и от необобщенных классов/интерфейсов.

**Правила наследования:**
* Обобщенный класс → обобщенный класс:
    ```C#
    public class Base<T> { /* ... */ }
    public class Derived<T> : Base<T> { /* ... */ }
    ```
* Обобщенный класс → конкретный класс:
    ```C#
    public class Derived : Base<string> { /* ... */ } // Base фиксируется к string
    ```
* Конкретный класс → обобщенный класс:
    ```C#
    public class Base { /* ... */ }
    public class Derived<T> : Base { /* ... */ }
    ```

**Пример наследования с параметрами:**
```C#
public class Animal { /* Базовый класс */ }
public class Cat : Animal { /* Наследник */ }

public class Cage<T> where T : Animal {
    public T CurrentAnimal { get; set; }
}

public class CatCage : Cage<Cat> {
    // Может работать только с Cat
}
```

### Ограничения на типы в обобщениях
Ограничения (`constraints`) задают правила для параметров типа, чтобы гарантировать доступность методов, свойств или поведения.

**Типы ограничений:**
|Ограничение|Описание|
|---|---|
|`where T : class`|T должен быть ссылочным типом (класс, интерфейс, делегат).|
|`where T : struct`|T должен быть значимым типом `int`, `DateTime`, собственные `struct`.|
|`where T : new()`|T должен иметь конструктор без параметров.|
|`where T : <base class>`|T должен наследовать указанный базовый класс. |
|`where T : <interface>`|T должен реализовать указанный интерфейс.|
|`where T : U`|T должен быть или наследовать тип U.|


**Примеры использования:**
```C#
public class Repository<T> where T : class, IEntity, new() {
    public T Create() {
        T item = new T(); // new() позволяет создать экземпляр
        return item;
    }
}
```

**Комбинация ограничений:**
```C#
public class Processor<T> where T : class, IComparable<T>, new() {
    // T должен быть ссылочным типом, реализовать IComparable<T> и иметь конструктор
}
```


### Отличие от boxing/unboxing
**Boxing/unboxing** — это процесс упаковки и распаковки значимых типов (`int`, `bool`, `DateTime`) в/из ссылочного типа `object`.

**Boxing (упаковка):**
```C#
int number = 42;
object obj = number; // Boxing: int → object
```

**Unboxing (распаковка):**
```C#
object obj = 42;
int number = (int)obj; // Unboxing: object → int
```

**Проблемы boxing/unboxing:**
* Производительность : дополнительные операции копирования.
* Ошибка времени выполнения : если тип не совпадает.

**Как обобщения решают эти проблемы?**
* Обобщения работают с конкретными типами , избегая преобразования в object.
* Пример:
```C#
// С использованием object (boxing/unboxing)
List<object> list = new List<object>();
list.Add(1); // Boxing
int number = (int)list[0]; // Unboxing

// С обобщением
List<int> list = new List<int>();
list.Add(1); // Без boxing
int number = list[0]; // Без cast
```

## 12. Массивы и коллекции. Инициализация и использование. Отличия Array от List<T>. Преимущества использования Dictionary<TKey, TValue> ? 

### Массивы и коллекции: инициализация и использование
**Массивы** (`Array`) и **коллекции** (`List<T>`, `Dictionary<TKey, TValue>`) — это структуры данных для хранения элементов. Они отличаются по гибкости, производительности и функциональности.

**Массив (`Array`)** — это статическая коллекция, которая хранит элементы фиксированного размера одного типа.

```C#
// Пример 1: Объявление и инициализация
int[] numbers = new int[5]; // Массив из 5 элементов
numbers[0] = 10;

// Пример 2: Инициализатор
string[] names = { "Alice", "Bob" };

// Пример 3: Многомерный массив
int[,] matrix = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };
```

**Особенности:**

* Индексация начинается с `0`.
* Размер массива неизменен после создания.
* Эффективен для чтения по индексу (время `O(1)`).
* Для изменения размера требуется создать новый массив и скопировать элементы:
    ```C#
    Array.Resize(ref numbers, 10); // Создает новый массив из 10 элементов
    ```

**Коллекции (`List<T>`)** — это динамическая коллекция, реализованная на основе массива, которая автоматически управляет размером.

```C#
// Пример 1: Пустой список
List<int> numbers = new List<int>();

// Пример 2: Инициализатор коллекции
List<string> names = new List<string> { "Alice", "Bob" };

// Пример 3: Указание начальной емкости (оптимизация)
List<int> largeList = new List<int>(1000); // Емкость = 1000
```

**Операции:**
```C#
// Добавление элементов
numbers.Add(42);
numbers.AddRange(new int[] { 1, 2, 3 });

// Удаление элементов
numbers.Remove(42); // Удаление по значению
numbers.RemoveAt(0); // Удаление по индексу

// Поиск и проверка
bool exists = numbers.Contains(42);
int index = numbers.IndexOf(42);
```

**Особенности:**
* Динамическое изменение размера (автоматическое увеличение массива).
* Поддержка LINQ и методов `IEnumerable<T>`.
* Меньше кода для управления размером по сравнению с массивами.

### Отличия `Array` от `List<T>`

|Критерии|Масиив `Array`|Список `List<T>`|
|---|---|---|
|Размер|Фиксированный|Фиксированный
|Изменение размера|	Требует копирования в новый массив|Автоматическое управление
|Методы|Минимальный набор (Length, Rank, SetValue)|Богатый набор (Add, Remove, Find, Sort)
|Производительность|Быстрый доступ по индексу (O(1))|Немного медленнее (за счет динамики)
|Типобезопасность|Нет (работает с object в необобщенных версиях)|Полностью типобезопасен
|Совместимость|Универсальная (поддержка в старых API)|Требует .NET 2.0+
|Память|Меньше накладных расходов|Немного больше (за счет динамической емкости)

### Преимущества `Dictionary<TKey, TValue>`
`Dictionary<TKey, TValue>` — это коллекция пар ключ-значение, где ключ уникаен , а доступ к элементам осуществляется за O(1) благодаря хэшированию.

```C#
// Пример 1: Обычная инициализация
Dictionary<string, int> ages = new Dictionary<string, int>();
ages["Alice"] = 30;
ages.Add("Bob", 25);

// Пример 2: Инициализатор коллекции
Dictionary<int, string> codes = new Dictionary<int, string> {
    { 1, "One" },
    { 2, "Two" }
};
```

**Операции:**
```C#
// Добавление элементов
ages.Add("Charlie", 40);
// Проверка наличия ключа
if (ages.ContainsKey("Alice")) { /* ... */ }
// Получение значения
if (ages.TryGetValue("Alice", out int age)) {
    Console.WriteLine(age);
}
// Удаление
ages.Remove("Bob");
```

**Преимущества:**
* Быстрый поиск по ключу (O(1)).
* Гибкость в выборе типа ключа (например, строки, объекты, пользовательские типы).
Ч* итаемость кода : логика работы с данными становится более понятной (например, `user.Password` вместо `users[2]`).

**Ограничения:**
* Порядок элементов не гарантирован (в отличие от `SortedDictionary<TKey, TValue>` или `OrderedDictionary`).
* Требуется корректная реализация `GetHashCode()` и `Equals()` для пользовательских типов ключей.
```C#
// Хранение настроек пользователя
Dictionary<string, object> settings = new Dictionary<string, object> {
    { "Theme", "Dark" },
    { "FontSize", 14 }
};

// Получение значения
if (settings.TryGetValue("Theme", out object theme)) {
    Console.WriteLine($"Текущая тема: {theme}");
}
```

### Рекомендации по использованию
* Используйте `Array` , если:
  * Размер коллекции известен заранее и не меняется.
  * Критична производительность (например, в циклах).
* Используйте `List<T>`, если:
  * Коллекция динамически изменяется.
  * Нужны методы Add, Remove, Find и т.д.
  * Требуется работа с LINQ.
* Используйте `Dictionary<TKey, TValue>`, если:
  * Нужен быстрый доступ к данным по ключу.
  * Ключи уникальны (например, идентификаторы, имена настроек).

### Итог
* Массивы (`Array`) — это простые и быстрые структуры для работы с фиксированным набором данных.
* Списки (`List<T>`) — более гибкая альтернатива массивам с динамическим управлением размера и богатым API.
* Словари (`Dictionary<TKey, TValue>`) — идеальный выбор для хранения данных с уникальными ключами и быстрым доступом.

## 13. Делегаты. Определение, объявление и вызов делегатов. Встроенные делегаты Action\Func\Predicate. Отличия от событий.

### Делегаты: определение, объявление и вызов
**Делегат** — это **тип** , представляющий ссылку на метод с определенной сигнатурой. Он позволяет передавать методы как параметры , использовать их для обратных вызовов или реализации шаблонов проектирования (например, Observer).

**Объявление делегата:**
```C#
// Определение делегата
public delegate void MyDelegate(string message);

// Класс с методом, соответствующим сигнатуре делегата
public class Printer {
    public void Print(string text) => Console.WriteLine(text);
}
```

**Создание и вызов делегата**
```C#
Printer printer = new Printer();
MyDelegate del = new MyDelegate(printer.Print); // Создание делегата
del("Hello, world!"); // Вызов делегата
```

**Мульткаст (цепочка делегатов):**
```C#
MyDelegate del1 = printer.Print;
MyDelegate del2 = Console.WriteLine;

MyDelegate multiDel = del1 + del2; // Объединение делегатов
multiDel("Message"); // Вызов обоих методов
```

### Встроенные делегаты: `Action`, `Func`, `Predicate`

`Action<T>` - Представляет метод, не возвращающий значение и принимающий один или несколько параметров .
```C#
Action<string> logAction = Console.WriteLine;
logAction("Logging message");
```

`Func<T, TResult>` - Представляет метод, возвращающий значение и принимающий один или несколько параметров.

```C#
Func<int, int, int> add = (a, b) => a + b;
int result = add(3, 5); // 8
```

`Predicate<T>` - Устаревший, но часто используется для проверок. Возвращает `bool` и принимает один параметр.

```C#
Predicate<int> isEven = x => x % 2 == 0;
bool even = isEven(4); // true
```

**Преимущества встроенных делегатов:**

* Не нужно создавать собственные делегаты для стандартных сценариев.
* Поддержка лямбд и анонимных методов.
* Используются в LINQ, коллекциях и асинхронном программировании.

## 14. События\Event. Определение, объявление и вызов событий. Методы Add и Remove. Отличия от делегатов

### Определение событий
**Событие (`event`)** — это механизм, позволяющий классу уведомлять другие части программы о наступлении какого-либо действия (например, клик мыши, завершение загрузки файла). События строятся на основе делегатов , но добавляют ограничения для обеспечения безопасности и инкапсуляции.

Пример использования:
* Уведомления о действиях в UI (например, нажатие кнопки).
* Реакция на изменения состояния объекта (например, обновление данных).

### Объявление и вызов событий
**Шаг 1: Объявление события**
```C#
public class Button {
    // Объявление события с использованием стандартного делегата EventHandler
    public event EventHandler Click;
}
```
* `EventHandler` : стандартный делегат, принимающий два параметра:
* `object sender` — ссылка на объект, вызвавший событие.
* `EventArgs e` — данные события (может быть пустым, если данные не нужны).

**Шаг 2: Вызов события**
Для вызова события создается метод `On...` (по соглашению), который проверяет наличие подписчиков и вызывает событие:

```C#
public class Button {
    public event EventHandler Click;

    // Метод для вызова события
    public void OnClick() {
        // Проверка на null и вызов события
        Click?.Invoke(this, EventArgs.Empty);
    }
}
```

**Шаг 3: Подписка на событие**
```C#
Button button = new Button();

// Подписка на событие с помощью лямбда-выражения
button.Click += (sender, e) => Console.WriteLine("Кнопка нажата!");

// Вызов метода, который инициирует событие
button.OnClick(); // Выведет: "Кнопка нажата!"
```

### Методы Add и Remove для событий

По умолчанию события управляются через опера    торы `+=` и `-=`. Однако можно явно определить методы `add` и `remove` , чтобы добавить логику при подписке/отписке

**Пример с кастомными методами add/remove:**
```C#
public class Button {
    private EventHandler _clickHandler;

    public event EventHandler Click {
        add {
            Console.WriteLine("Подписка на событие");
            _clickHandler += value;
        }
        remove {
            Console.WriteLine("Отписка от события");
            _clickHandler -= value;
        }
    }

    public void OnClick() {
        _clickHandler?.Invoke(this, EventArgs.Empty);
    }
}

// Использование
Button button = new Button();

button.Click += (s, e) => Console.WriteLine("Обработчик 1");
button.Click += (s, e) => Console.WriteLine("Обработчик 2");

button.OnClick(); // Вызов всех подписчиков

button.Click -= (s, e) => Console.WriteLine("Обработчик 2"); // Отписка
```
**Зачем это нужно?**
* Логирование подписок/отписок.
* Проверка условий перед добавлением/удалением обработчика.
* Интеграция с другими системами (например, счетчик активных подписчиков).

### Пример реального использования: событие с данными
```C#
// Создание пользовательского EventArgs
public class MouseEventArgs : EventArgs {
    public int X { get; set; }
    public int Y { get; set; }
}

// Объявление события с пользовательскими данными
public class Button {
    public event EventHandler<MouseEventArgs> Click;

    public void OnClick(int x, int y) {
        Click?.Invoke(this, new MouseEventArgs { X = x, Y = y });
    }
}

// Использование события
Button button = new Button();
button.Click += (sender, e) => {
    Console.WriteLine($"Клик по координатам: X={e.X}, Y={e.Y}");
};

button.OnClick(100, 200); // Выведет: "Клик по координатам: X=100, Y=200"
```

## 13 и 14 Общее. Отличия событий от делегатов

**Делегат** — это тип , представляющий ссылку на метод с определённой сигнатурой. Позволяет:
* Передавать методы как параметры.
* Реализовывать callback-функции.
* Использовать в LINQ, асинхронности и других сценариях.

**Событие** — это механизм , построенный на делегатах, для реализации шаблона "Издатель-Подписчик". Позволяет:
* Уведомлять объекты о наступлении действий (например, клик мыши, завершение загрузки).
* Ограничивать доступ: событие можно подписаться/отписаться , но нельзя вызвать напрямую извне класса.

|Критерий|Делегаты|События|
|---|---|---|
|Цель|Хранение ссылки на метод|Реализация шаблона "Издатель-Подписчик"|
|Доступ|Может быть вызван из любого места|Вызывается    только внутри класса, где объявлен|
|Синтаксис подписки|`+=`,`-=`|`+=`,`-=`|
|Контроль вызова|Полный контроль (можно вызвать напрямую)|Ограниченный (вызов через методы класса)|
|Пример использования|Callback-функции, LINQ, асинхронность|Обработка кликов, уведомления, события UI|

## 15. Многопоточное программирование. Понятие «поток», отличия от Task. Использование класса Thread. Делегаты ThreadStart и ParametrizedThreadStart. Запуск потока на выполнение. Примеры. Понятие CPU Bound, отличия от I\O Bound. Примеры операций CPU Bound. Пул потоков

### Понятие «поток», отличия от Task.

**Поток (Thread)** — это минимальная единица выполнения в процессе, которая может работать независимо от других потоков.

**Особенности:**
* Каждый процесс имеет минимум один поток (главный).
* Потоки разделяют память процесса.
* Управление потоками — задача ОС и .NET Runtime.

**Класс `Thread` в .NET:**

```C#
Thread thread = new Thread(() => {
    Console.WriteLine("Выполняется в отдельном потоке");
});
thread.Start();
```

**Task (задача)** — это абстракция асинхронной операции в .NET, которая упрощает работу с многопоточностью, параллелизмом и асинхронными операциями. Он является частью TPL (Task Parallel Library) — библиотеки параллельных задач, введенной в .NET 4.0.

**К чему относится Task?**
* Многопоточность (Multithreading):
  * `Task` может выполнять код в отдельном потоке из пула потоков (`ThreadPool`).
  * Используется для **CPU-bound** операций (например, вычисления, обработка данных).
* Асинхронность (Asynchronous programming):
  * `Task` работает с ключевыми словами `async/await` для асинхронного программирования.
  * Используется для **I/O-bound** операций (например, чтение файла, HTTP-запросы, работа с базой данных).
* Параллелизм (Parallelism):
  * Позволяет выполнять несколько задач одновременно (например, через `Task.Run`, `Task.WhenAll`).

### Чем `Task` отличается от `Thread`?

|Критерий|`Thread`|`Task`|
|---|---|---|
|Уровень абстракции|Низкий уровень (работа напрямую с ОС)|Высокий уровень (TPL, async/await)|
|Управление|Ручное создание и управление|Автоматическое (через пул потоков)|
|Производительность|Накладные расходы на создание|Оптимизация через `ThreadPool`|
|Асинхронность|Требует ручной реализации|Встроенная поддержка (`async/await`)|

### Использование класса `Thread`
Для создания потока применяется один из конструкторов класса **Thread**:

**Thread(ThreadStart)**: в качестве параметра принимает объект делегата ThreadStart, который представляет выполняемое в потоке действие

**Thread(ThreadStart, Int32)**: в дополнение к делегату ThreadStart принимает числовое значение, которое устанавливает размер стека, выделяемого под данный поток

**Thread(ParameterizedThreadStart)**: в качестве параметра принимает объект делегата ParameterizedThreadStart, который представляет выполняемое в потоке действие

**Thread(ParameterizedThreadStart, Int32)**: вместе с делегатом ParameterizedThreadStart принимает числовое значение, которое устанавливает размер стека для данного потока

**Изпользование ThreadStart**
```C#
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // Создаем поток, передавая метод DoWork через делегат ThreadStart
        Thread thread = new Thread(DoWork);
        thread.Start(); // Запускаем поток
    }

    // Метод, который будет выполняться в отдельном потоке
    static void DoWork()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"Поток {Thread.CurrentThread.ManagedThreadId}: {i}");
            Thread.Sleep(100); // Имитация работы
        }
    }
}
```

**Изпользование ParameterizedThreadStart**
```C#
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        // Передаем параметр через Start()
        Thread thread = new Thread(ProcessData);
        thread.Start("Hello from thread!"); // Передаем строку как параметр
    }

    // Метод, принимающий параметр типа object
    static void ProcessData(object data)
    {
        string message = data as string;
        Console.WriteLine($"Получено сообщение: {message}");
    }
}
```

### Использование класса `Task`

Если вы используете `Task.Run()` или `Task.Factory.StartNew()` , задача будет выполняться в отдельном потоке из пула потоков (`ThreadPool`). Это подходит для **вычислений на процессоре** (например, сортировка массива, математические операции).

Если вы используете асинхронные методы (например, `HttpClient.GetStringAsync`, `FileStream.ReadAsync`), задача не занимает поток во время ожидания. Это подходит д**ля операций ввода-вывода** (например, чтение файла, HTTP-запрос, работа с базой данных).


**СPU-Bound задача:**
```C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Создаем задачу для вычисления факториала
        Task<int> task = Task.Run(CalculateFactorial);

        // Блокируем основной поток до завершения задачи
        task.Wait();
        // чтобы не блокировать поток стоит использовать следующую конструкцию
        // int result = await task;

        // Получаем результат после завершения задачи
        Console.WriteLine($"Факториал: {task.Result}");
    }

    // Метод для вычисления факториала
    static int CalculateFactorial()
    {
        int result = 1;
        for (int i = 1; i <= 5; i++)
        {
            result *= i;
        }
        return result;
    }
}
```

**I/O-bound**
```C#
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        // Создаем задачу для загрузки данных
        Task<string> task = DownloadPageAsync("https://example.com"); 

        // Блокируем основной поток до завершения задачи
        task.Wait();

        // Выводим первые 100 символов
        Console.WriteLine(task.Result.Substring(0, 100));
    }

    // Асинхронный метод для загрузки страницы
    static async Task<string> DownloadPageAsync(string url)
    {
        HttpClient client = new HttpClient();
        return await client.GetStringAsync(url);
    }
}
```

**Паралельный запуск задач**
```C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task<int> task1 = Task.Run(() => CalculateSum(1, 5));
        Task<int> task2 = Task.Run(() => CalculateSum(6, 10));

        // Блокируем до завершения всех задач
        Task.WaitAll(task1, task2);

        Console.WriteLine($"Сумма 1-5: {task1.Result}");
        Console.WriteLine($"Сумма 6-10: {task2.Result}");
    }

    // Метод для вычисления суммы
    static int CalculateSum(int start, int end)
    {
        int sum = 0;
        for (int i = start; i <= end; i++)
        {
            sum += i;
        }
        return sum;
    }
}
```

### CPU Bound vs I/O Bound

**CPU Bound** — операции, зависящие от мощности процессора.
  * Математические вычисления (например, факториал, сортировка массива).
  * Обработка изображений/видео.

**I/O Bound** — операции, зависящие от внешних ресурсов (сети, диска).
  * Чтение/запись файлов.
  * HTTP-запросы.


## 16. Конкурентный доступ к данным. Механизмы синхронизации потоков – мьютекс. Отличия от монитора/семаформа. Пример реализации. Реализация запуска только одного экземпляра приложения с помощью мьютекса <br> 17. Конкурентный доступ к данным. Механизмы синхронизации потоков – семафор. Отличия от мьютекса/монитора. Пример реализации. Реализация запуска только одного экземпляра приложения с помощью семаформа <br> 18. Конкурентный доступ к данным. Механизмы синхронизации потоков – монитор. Отличия от мьютекса/семафора. Пример реализации

### Конкурентный доступ к данным
**Конкурентный доступ к данным** — это ситуация, при которой несколько потоков или процессов одновременно пытаются читать или изменять одни и те же данные. Это явление возникает в многопоточных приложениях, где параллельные задачи разделяют общие ресурсы (например, переменные, файлы, базы данных). Если доступ к данным не синхронизирован, это может привести к непредсказуемым результатам , повреждению данных или сбоям программы .

**Основные проблемы конкурентного доступа:**
1) Гонка данных (Race Condition) 
   
   Возникает, когда результат работы программы зависит от чередования потоков. Например:

2) Несогласованность данных
   
   Если один поток изменяет структуру данных (например, список), а другой её читает, это может привести к исключениям или некорректным данным.

3) Тупики (Deadlock)
   
   Ситуация, когда два или более потоков ждут друг друга, заблокировав ресурсы, что приводит к зависанию программы.
4) Голодание (Starvation)
   
   Один поток постоянно не получает доступ к ресурсу из-за приоритетов других.

**Решение: Синхронизация потоков**
Для безопасного конкурентного доступа используются механизмы синхронизации:
* Мьютекс (Mutex)
* Монитор (Monitor)
* Семафор (Semaphore)


### Мьютекс (Mutex)
* **Определение:** Объект синхронизации, обеспечивающий взаимное исключение (только один поток может владеть мьютексом).
* **Применение:** Защита общих ресурсов от одновременного доступа.
* **Пример синхронизации:**
```C#
Mutex mutex = new Mutex();
int sharedCounter = 0;

Parallel.For(0, 100, i =>
{
    mutex.WaitOne(); // Захват мьютекса
    sharedCounter++;
    mutex.ReleaseMutex(); // Освобождение
});
Console.WriteLine(sharedCounter); // Вывод: 100
```
**Запуск одного экземпляра приложения:**
```C#
using (Mutex mutex = new Mutex(false, "MyUniqueAppMutex"))
{
    if (!mutex.WaitOne(TimeSpan.Zero)) // Проверка наличия мьютекса
    {
        Console.WriteLine("Приложение уже запущено.");
        return;
    }
    Console.WriteLine("Приложение запущено.");
    Console.ReadLine();
}
```

### Семафор (Semaphore)
* **Определение:** Управляет количеством потоков, которые могут одновременно получить доступ к ресурсу. Имеет счетчик разрешений.
* **Отличия от мьютекса/монитора:**
  * Позволяет заданное количество потоков (например, `Semaphore(2, 5)` — 2 активных, максимум 5).
  * Не привязан к владельцу (любой поток может вызвать `Release`).

* **Пример синхронизации:**
```C#
Semaphore semaphore = new Semaphore(2, 2); // 2 активных потока
for (int i = 0; i < 5; i++)
{
    int threadId = i;
    new Thread(() =>
    {
        semaphore.WaitOne(); // Ждем разрешения
        Console.WriteLine($"Поток {threadId} начал работу.");
        Thread.Sleep(1000);
        Console.WriteLine($"Поток {threadId} завершил работу.");
        semaphore.Release(); // Освобождаем
    }).Start();
}
```
**Запуск одного экземпляра приложения:**
```C#
using (Semaphore semaphore = new Semaphore(0, 1, "MyUniqueAppSemaphore"))
{
    if (semaphore.WaitOne(0)) // Если семафор свободен
        semaphore.Release(); // Освобождаем для других
    else
    {
        Console.WriteLine("Приложение уже запущено.");
        return;
    }
}
```


### Монитор (Monitor)
* **Определение:** Механизм синхронизации через блокировки объекта. Используется с ключевым словом lock.
* **Отличия от мьютекса/семафора:**
  * Привязан к конкретному объекту
  * Блокировка снимается автоматически при выходе из блока `lock`.
  * Не поддерживает ожидание с таймаутом или межпроцессный доступ.
* **Пример синхронизации:**
```C#
object lockObj = new object();
int sharedCounter = 0;

Parallel.For(0, 100, i =>
{
    lock (lockObj)
        sharedCounter++;
});
Console.WriteLine(sharedCounter); // Вывод: 100
```


### Когда что использовать?
* **Мьютекс:**
  * Нужна межпроцессная синхронизация.
  * Запуск одного экземпляра приложения.
  * Пример: Mutex для защиты файла, используемого несколькими процессами.
* **Семафор:**
  * Ограничение количества параллельных потоков.
  * Пример: Пул подключений к БД (ограничение на 5 одновременных запросов).
* **Монитор:**
  * Простая синхронизация внутри процесса.
  * Пример: Обновление общего списка данных в одном приложении.

## 19. Асинхронное программирование. Понятие «Task», отличие от потока. Ключевые слова async\await. Отличия Monitor.Wait() \ Task.Delay() \ Thread.Sleep(). Понятие I\O Bound, отличия от CPU Bound. Примеры операций I\O Bound. Типы возвращаемых значений для асинхронного метода (void, Task, Task<T>, ValueTask и их отличия)

### Понятие Task и его отличие от потока

**`Task`** — это абстракция асинхронной операции, упрощающая управление параллелизмом.
* Работает на основе пула потоков (ThreadPool) или I/O-операций (например, при работе с сетью или диском).
* Не блокирует поток, если операция связана с ожиданием (I/O Bound).
* Пример:
    ```C#
    Task<int> task = Task.Run(() => 
    {
        Thread.Sleep(1000);
        return 42;
    });
    Console.WriteLine(await task); // Вывод: 42
    ```
**Поток (`Thread`)** — это низкоуровневый механизм ОС, который требует ручного управления.
* Каждый поток занимает память (около 1 МБ) и имеет накладные расходы на переключение контекста.
* Пример:
    ```C#
    Thread thread = new Thread(() => 
    {
        Thread.Sleep(1000);
        Console.WriteLine("Поток завершен.");
    });
    thread.Start();
    ```
**Отличие:**

* `Task` управляет потоками автоматически (через `TaskScheduler`), тогда как `Thread` требует ручного контроля.
* Task поддерживает асинхронность через `async/await`, а `Thread` — нет.

### Ключевые слова `async` и `await`

* **`async`** — маркирует метод как асинхронный, позволяя использовать await.

* **`await`** — приостанавливает выполнение метода до завершения задачи (Task), не блокируя поток

**Пример:**
```C#
async Task<int> GetDataAsync()
{
    // Симуляция I/O операции (например, загрузка данных)
    await Task.Delay(1000);
    return 42;
}

async Task UseDataAsync()
{
    int result = await GetDataAsync(); // Не блокирует поток
    Console.WriteLine(result); // Вывод: 42
}
```

**Как это работает:**
* Компилятор преобразует `async`-метод в автоматат, который управляет состояниями асинхронных операций.
* `await` возвращает управление вызывающему коду, освобождая поток для других задач.

### Отличия Monitor.Wait(), Task.Delay() и Thread.Sleep()

|Метод||||
|---|---|---|---|
|`Monitor.Wait()`|Ожидает сигнала от другого потока (внутри)|Да|Синхронизация между потоками.|
|`Task.Delay()`|Создает задачу, которая завершается через заданное время.|Нет|Асинхронное ожидание без блокировки потока.|
|`Thread.Sleep()`|Создает задачу, которая завершается через заданное время.|Да|Простое ожидание (не рекомендуется в UI).|

**Примеры:**
```C#
// Monitor.Wait()
object lockObj = new object();
lock (lockObj)
{
    Monitor.Wait(lockObj, TimeSpan.FromSeconds(1)); // Ожидает сигнала или таймаута
}

// Task.Delay()
await Task.Delay(1000); // Асинхронное ожидание 1 секунды

// Thread.Sleep()
Thread.Sleep(1000); // Блокирует текущий поток на 1 секунду
```

### I/O Bound vs. CPU Bound
**I/O Bound** — операции, зависящие от внешних ресурсов (сеть, диск, базы данных).
* Не требуют активного использования процессора.
* Примеры:
  * Чтение/запись файла.
  * HTTP-запрос.
  * Запрос к базе данных.

**CPU Bound**— операции, требующие вычислений.
* Используют процессорное время.
* Примеры:
  * Сортировка массива.
  * Шифрование данных.
  * Машинное обучение.
  
* Для I/O Bound лучше использовать асинхронность (`async/await`), чтобы не блокировать поток.
* Для CPU Bound — параллелизм (`Parallel.For`, `Task.Run`).

### Типы возвращаемых значений асинхронных методов

|Тип|Описание|Использование|
|---|---|---|
|`void`|Асинхронный метод без возврата результата.|События (например,`button.Click += async (s, e) => {}`).|
|`Task`|Представляет асинхронную операцию без возвращаемого значения.|Методы, выполняющие I/O операции.|
|`Task<T>`|Представляет асинхронную операцию, возвращающую значение типа `T`|Методы, возвращающие результат (например, данные).|
|`ValueTask`|Легковесная альтернатива `Task`, оптимизированная для краткосрочных операций.|Методы с частыми короткими операциями (например, кэширование).|

**Когда использовать:**
* `Task/Task<T>` — стандартные асинхронные методы.
* `ValueTask` — для оптимизации, если операция часто завершается мгновенно.
* `void` — только для событий (не рекомендуется для бизнес-логики).

### Некоторые особенности Task и ValueTask

Task - Класс (ссылочный тип) и может вызываться несколько раз через await

ValueTask - Структура (ссылочный тип), не поддерживает повторный вызов


## 20. Преобразование async/await при компиляции. Интерфейс IAsyncStateMachine при реализации State Machine 

Когда вы пишете асинхронный метод с использованием `async/await`, компилятор C# преобразует его в автомат состояний (state machine) , реализующий интерфейс `IAsyncStateMachine`. Это позволяет управлять асинхронными операциями без блокировки потока.

Как компилятор обрабатывает этот код:

* Создает скрытую структуру или класс, реализующий `IAsyncStateMachine`.
* Разбивает метод на части, разделенные ключевыми словами `await`.
* Использует продолжения **(continuations)** для перехода между состояниями после завершения задачи.

**Пример исходного кода**
```C#
async Task<int> ExampleMethodAsync()
{
    await Task.Delay(1000);
    return 42;
}
```

### Интерфейс IAsyncStateMachine

Этот интерфейс определяет два метода:
* `void MoveNext()` — выполняет переход к следующему состоянию.
* `void SetStateMachine(IAsyncStateMachine stateMachine)` — устанавливает контекст состояния.

**Пример генерируемого кода (упрощенно) :**
```C#
private struct ExampleMethodAsyncStateMachine : IAsyncStateMachine
{
    public int state;
    public AsyncTaskMethodBuilder<int> builder;
    private TaskAwaiter awaiter;

    void IAsyncStateMachine.MoveNext()
    {
        try
        {
            if (state == 0)
            {
                // Первая часть: await Task.Delay(1000)
                awaiter = Task.Delay(1000).GetAwaiter();
                if (!awaiter.IsCompleted)
                {
                    state = 1;
                    awaiter.OnCompleted(builder.SetResult);
                    return;
                }
            }

            if (state == 1)
            {
                // Вторая часть: возврат результата
                builder.SetResult(42);
            }
        }
        catch (Exception ex)
        {
            builder.SetException(ex);
        }
    }

    void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
    {
        builder.SetStateMachine(stateMachine);
    }
}s
```

### Ключевые моменты реализации

* **Разделение на состояния:** Каждый `await` создает новое состояние в автомате.
* **Контекст выполнения (`SynchronizationContext`):**
  * Если await выполняется в UI-потоке (например, `WPF/WinForms`), продолжение (`MoveNext`) будет запущено в том же потоке.
  * Для консольных приложений используется `ThreadPool`.
* **Продолжения:** Метод `OnCompleted` регистрирует продолжение, которое вызывается после завершения задачи.
* **Оптимизация с `ValueTask`:** Если задача уже завершена, `await` не создает аллокаций. (Аллокации — это выделение памяти для объектов в куче (heap))

### Пример преобразования `async/await`

**Исходный код:**
```C#
async Task<int> AddAsync(int a, int b)
{
    await Task.Delay(1000);
    return a + b;
}
```

**Генерируемый код (схематично):**
1) **Создание билдера:**
```C#
   AsyncTaskMethodBuilder<int> builder = AsyncTaskMethodBuilder<int>.Create();
```

2) **Первое состояние:**
   * Вызов `Task.Delay(1000)`.
   * Если задача не завершена, регистрируется продолжение (`MoveNext`).
3) **Второе состояние:**
   * После завершения `Task.Delay`, возвращается результат `a + b`.

### Важные детали реализации

**Аллокация памяти**
* `Task` всегда создает объект в куче
* `ValueTask` минимизирует аллокации, если операция завершена синхронно

**Захват переменных**
* Локальные переменные и параметры метода захватываются в структуре состояния.

**Обработка исключений**
* Исключения в `try` блоке передаются через `builder.SetException`


## 21. Цикломатическая сложность кода, примеры вычисления. «Запахи» кода и способы их устранения. Принципы DRY, KISS, YAGNI

### Цикломатическая сложность кода

**Цикломатическая сложность** - метрика, измеряющая количество независимых путей выполнения в коде. Чем выше сложность, тем сложнее тестировать и поддерживать код.

**Формула:**
`M = E - N + 2P`, где:

* E — количество рёбер (ветвлений, переходов).
* N — количество узлов (операторов, шагов).
* P — количество компонент связности (обычно 1 для одного метода).

### «Запахи» кода (Code Smells) и их устранение

**«Запахи»** — признаки плохого дизайна, затрудняющие поддержку кода.

|Запах|Описание|Способ устранения|
|---|---|---|
|Длинный метод|Метод выполняет много действий.|Разбить на подметоды через Extract Method|
|Дублирование кода|Одинаковые блоки кода в разных местах.|Вынести общий код в отдельный метод/класс.|
|Большой класс|Класс отвечает за слишком многое.|Применить принцип единственной ответственности (SRP).|
|Зелёная лужа (Primitive Obsession)|Использование примитивов вместо объектов.|Создать собственный тип данных.|
|Жадный метод (Feature Envy)|Метод использует данные другого класса.|Перенести метод в класс, владеющий данными.|
|Магические числа|Числа без пояснений (например, x * 0.15).|Заменить на константы или enum.|
|Слепой метод (Inappropriate Intimacy)|Классы слишком зависимы друг от друга.|Уменьшить связность через инкапсуляцию.|

### Принципы DRY, KISS, YAGNI

* **DRY (Don’t Repeat Yourself)** - Не повторяй логику.
* **KISS (Keep It Simple, Stupid)** - Код должен быть максимально простым.
* **YAGNI (You Aren’t Gonna Need It)** - Не добавляй функционал, который пока не используется.



## 22. Антипаттерны примеры, опасность использования и способы избежания (God Object, Spaghetti Code, Middle Man, Cargo Cult Programming, Anemic Domain Model)

**Антипаттерны** — это распространённые практики разработки, которые приводят к ухудшению качества кода, снижению читаемости, увеличению сложности поддержки и риску ошибок. Рассмотрим основные антипаттерны, их последствия и методы устранения.

**God Object** (Божественный объект) - Класс или модуль, который берет на себя слишком много функциональности, нарушает принцип единственной ответственности (SRP)

**Пример:** Класс `ApplicationManager`, который одновременно обрабатывает ввод данных, валидацию, сохранение в БД и генерацию отчетов.

* Опасности :
  * Сложность тестирования и отладки.
  * Низкая повторная используемость (reusability).
  * Высокая связность (tight coupling) между компонентами.
* Способы избежания :
  * Разделите класс на специализированные модули:

**Spaghetti Code** (Спагетти-код) - Запутанный, плохо структурированный код с множеством ветвлений, циклов и условий.

**Пример:** Функция с десятками if-else, глобальными переменными и дублированием логики.

* Опасность :
  * Низкая читаемость, что затрудняет поддержку.
  * Высокий риск ошибок при модификации.
  * Сложность рефакторинга.
* Способы избежания :
  * Разбиение кода на функции/методы с одной задачей.
  * Использование паттернов (например, Template Method, State).
  * Соблюдение принципов Clean Code (имена, длина методов, DRY).

**Middle Man (Посредник)** - Класс, который просто делегирует вызовы другим объектам без добавления собственной логики. Это избыточная абстракция.

**Пример:** Сервис `OrderService`, который только вызывает методы `OrderRepository` без дополнительной обработки.

* Опасность :
  * Лишние уровни абстракции, затрудняющие понимание кода.
  * Увеличение сложности системы.
  * Нарушение принципа минимального знания (Law of Demeter).
* Способы избежания :
  * Удаление бесполезных посредников.
  * Делегирование напрямую целевому объекту.
  * Использование паттерна Facade только при необходимости для упрощения интерфейса.

**Cargo Cult Programming (Культ груза)** - Слепое копирование кода или практик без понимания их сути. Программист следует шаблонам, не анализируя их применимость.

**Пример:** Использование паттерна Singleton для всех классов, даже когда это не требуется.

* Опасность:
  * Применение неподходящих решений, ведущее к техническому долгу.
  * Снижение качества архитектуры.
  * Трудности в поддержке и масштабировании.
* Способы избежания :
  * Обучение принципам проектирования (SOLID, DRY, KISS).
  * Рецензия кода и Pair Programming для анализа решений.
  * Понимание контекста использования паттернов.

**Anemic Domain Model (Анемичная предметная модель)** - Модель домена, содержащая только данные (геттеры/сеттеры) без бизнес-логики. Логика выносится во внешние сервисы.

**Пример:** Класс Account с полями balance и методами getBalance(), setBalance(), а логика перевода денег реализована в отдельном сервисе.

* Опасность :
  * Нарушение инкапсуляции и принципа ООП (данные + поведение).
  * Сложность поддержки распределенной логики.
  * Высокая связанность между слоями.
* Способы избежания :
  * Перенос бизнес-логики в доменные объекты.
  * Использование Domain-Driven Design (DDD).
  * Применение паттернов, таких как Specification или Repository.



## 23. LINQ. Основные операторы. Запросный и метод-синтаксис, примеры реализации фильтрации и сортировки коллекции объектов по нескольким критериям. 