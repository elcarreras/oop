# Экзамен ООП

## 1. Понятие объектно-ориентированного программирования (ООП). Основные принципы ООП. Наследование, агрегация, композиция. Примеры реализации принципов ООП в ЯП C#.
**ООП** - это парадигма программирования, основанная на объектах, которые объединяют данные (поля, свойства) и поведение (методы).

### **4 основынх принципа ООП:**
1)	**Абстракция** – упрощение сложной системы путем выделения наиболее важных характеристик и игнорирования второстепенных. В ООП абстракция реализуется через создание классов, которые представляют собой обобщенные модели объектов.
```C#
// Абстракция (интерфейс)
public interface IShape {
    double GetArea();  // Абстрактный метод
}
```

2) **Инкапсуляция** – скрытие внутренней реализации объекта и предоставления безопасного интерфейса для работы с ним. 
2)	**Наследование** – возможность создать новый класс на основе существующих с повторным использованием кода
работы с ним. 
```C#
// Инкапсуляция и наследование
public class Rectangle : IShape {
    private double _width;  // Инкапсуляция (private поле)
    private double _height;

    public Rectangle(double width, double height) {
        _width = width;
        _height = height;
    }
    
    // Реализация интерфейса
    public double GetArea() => _width * _height;  
}
```
3)	**Полиморфизм** – возможность объектов  одинаковым интерфейсом иметь разную реализацию 
```C#
// Полиморфизм (разные реализации одного интерфейса)
public class Circle : IShape {
    private double _radius;

    public Circle(double radius) => _radius = radius;

    public double GetArea() => Math.PI * _radius * _radius;
}
```
Использование кода принципов ООП вместе:
```C#
// Использование
var canvas = new Canvas();
canvas.AddShape(new Rectangle(10, 20));  // Полиморфизм
canvas.AddShape(new Circle(5));

foreach (var shape in canvas.Shapes) {
    Console.WriteLine($"Area: {shape.GetArea()}");
}
```


### **Наследование, агрегация и композиция:**

1) **Наследование** - класс-наследник (подкласс) получает все поля и методы родительского класса.
```C#
public class Animal {
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal {  // Наследование
    public void Bark() => Console.WriteLine("Barking...");
}

var dog = new Dog();
dog.Eat();  // Метод родителя
dog.Bark(); // Свой метод
```
2) **Агрегация** - Объект содержит другой объект, но они могут существовать независимо.
```C#
public class Engine { }  // Двигатель может быть без машины

public class Car {
    private Engine _engine;
    
    // Двигатель передается извне
    public Car(Engine engine) {
        _engine = engine;
    }
}

var engine = new Engine();
var car = new Car(engine);  // Машина использует существующий двигатель
```
3) **Композиция** - Объект владеет другим объектом, и зависимый объект не существует без основного.
```C#
public class Heart { }  // Сердце не существует без тела

public class Human {
    private Heart _heart;
    
    // Сердце создается при создании человека
    public Human() {
        _heart = new Heart();  // Композиция
    }
}

var human = new Human();  // Сердце создается автоматически
```

## 2. Понятие класса. Основные элементы классов. Отличия класса и объекта.

**Класс** — это шаблон или описание для создания объектов в ООП. Он определяет:

* **данные (поля, свойства)** — характеристики объекта
* **поведение (методы)** — действия, которые объект может выполнять.
* **правила доступа** (модификаторы `private`, `public` и др.).

Класс описывает **абстрактную сущность**, например, `Car`, `Person`, `Student`, а объект — это **конкретный экземпляр** этого класса (например, `myCar`, `johnDoe`).

**Основные элементы класса:**
* Поля
* Методы

**Пример класса:**
```C#
public class Person 
{
    // Поля (данные)
    private string _name;
    private int _age;

    // Конструктор (инициализация объекта)
    public Person(string name, int age) 
    {
        _name = name;
        _age = age;
    }

    // Метод (поведение)
    public void Greet() 
    {
        Console.WriteLine($"Привет, меня зовут {_name} и мне {_age} лет.");
    }
}
```
**Итог:**
* **Класс** — это шаблон с описанием структуры и поведения.
* **Объект** — конкретная "реализация" класса, созданная через `new`.
* **Основные элементы класса**: поля, методы.

## 3. Ссылочные и значимые типы данных. Примеры, объявление и инициализация переменных. Приведение ссылочных и значимых типов данных. Понтие nullable типов данных

### Ссылочные и значимые типы данных.

**Значимые типы (Value Types)**:
* Хранят непосредственно значение в стеке (stack).
* Копируются по значению (при присваивании создается копия).
* Примеры:
  * Простые типы: `int`, `float`, `double`, `bool`, `char`, `struct`, `enum`.
  * Особый случай: `decimal` (хранится как структура).

**Ссылочные типы (Reference Types)**:
* Хранят ссылку на объект в куче (heap), а сам объект — в управляемой памяти.
* Копируются по ссылке (при присваивании копируется только ссылка).
* Примеры:
  * `class`, `interface`, `string`, `object`, `dynamic`, массивы (`int[]`).
  
**Stack (стек)**
* Что хранится:
  * Значимые типы (`int`, `bool`, `struct`, `enum`).
  * Ссылки на объекты в куче (адреса).
* Особенности:
  * Быстрый доступ (как LIFO-буфер).
  * Автоматическое управление памятью (освобождается при выходе из метода).
  * Ограниченный размер (переполнение → StackOverflowException).

**Heap (куча)**
* Что хранится:
  * Объекты ссылочных типов (`class`, `string`, `массивы`)
* Особенности:
  * Динамическое выделение памяти.
  * Управляется Garbage Collector (GC) (автоматически удаляет неиспользуемые объекты).
  * Медленнее стека (из-за сложности управления).

### Примеры объявления и инициализации

**Значимые типы**
```csharp
int number = 10;                  // Инициализация числа
bool isActive = true;             // Логический тип
char letter = 'A';                // Символ
DateTime date = DateTime.Now;     // Структура (значимый тип)s
```

**Ссылочные типы**
```csharp
string name = "Alice";            // Строка (ссылочный)
int[] numbers = { 1, 2, 3 };      // Массив
object obj = new object();        // Базовый класс
List<int> list = new List<int>(); // Коллекция
```

### Приведение ссылочных и значимых типов данных

**Явное и неявное приведение**
```csharp
// Неявное (автоматическое)
int a = 10;
double b = a;  // int → double (без потерь)

// Явное (ручное)
double c = 10.5;
int d = (int)c;  // double → int (дробная часть отбрасывается)

```

**Приведение ссылочных типов**
```csharp
Upcasting (восходящее, безопасное):

Downcasting (нисходящее, требует проверки):

```

### Nullable-типы
**Nullable-типы** позволяют значимым типам (value types) принимать значение `null`, что невозможно в обычных условиях
* Используются, когда переменная может отсутствовать (например, данные из БД, опциональные параметры)
* Обозначаются символом ? или через структуру Nullable<T>.

```csharp
int? nullableInt = null;          // Эквивалентно Nullable<int>
bool? isDone = null;              // Nullable<bool>

// Проверка и получение значения
if (nullableInt.HasValue) {
    int value = nullableInt.Value;  // Безопасное извлечение
}
// Или с оператором ?? (значение по умолчанию)
int result = nullableInt ?? 0;      // Если null, вернет 0
```