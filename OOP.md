# Экзамен ООП

## 1. Понятие объектно-ориентированного программирования (ООП). Основные принципы ООП. Наследование, агрегация, композиция. Примеры реализации принципов ООП в ЯП C#.
**ООП** - это парадигма программирования, основанная на объектах, которые объединяют данные (поля, свойства) и поведение (методы).

### **4 основyных принципа ООП:**
1)	**Абстракция** – упрощение сложной системы путем выделения наиболее важных характеристик и игнорирования второстепенных. В ООП абстракция реализуется через создание классов, которые представляют собой обобщенные модели объектов.
```C#
// Абстракция (интерфейс)
public interface IShape {
    double GetArea();  // Абстрактный метод
}
```

2) **Инкапсуляция** – скрытие внутренней реализации объекта и предоставления безопасного интерфейса для работы с ним. 
2)	**Наследование** – возможность создать новый класс на основе существующих с повторным использованием кода
работы с ним. 
```C#
// Инкапсуляция и наследование
public class Rectangle : IShape {
    private double _width;  // Инкапсуляция (private поле)
    private double _height;

    public Rectangle(double width, double height) {
        _width = width;
        _height = height;
    }
    
    // Реализация интерфейса
    public double GetArea() => _width * _height;  
}
```
3)	**Полиморфизм** – возможность объектов  одинаковым интерфейсом иметь разную реализацию 
```C#
// Полиморфизм (разные реализации одного интерфейса)
public class Circle : IShape {
    private double _radius;

    public Circle(double radius) => _radius = radius;

    public double GetArea() => Math.PI * _radius * _radius;
}
```
Использование кода принципов ООП вместе:
```C#
// Использование
var canvas = new Canvas();
canvas.AddShape(new Rectangle(10, 20));  // Полиморфизм
canvas.AddShape(new Circle(5));

foreach (var shape in canvas.Shapes) {
    Console.WriteLine($"Area: {shape.GetArea()}");
}
```


### **Наследование, агрегация и композиция:**

1) **Наследование** - класс-наследник (подкласс) получает все поля и методы родительского класса.
```C#
public class Animal {
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal {  // Наследование
    public void Bark() => Console.WriteLine("Barking...");
}

var dog = new Dog();
dog.Eat();  // Метод родителя
dog.Bark(); // Свой метод
```
2) **Агрегация** - Объект содержит другой объект, но они могут существовать независимо.
```C#
public class Engine { }  // Двигатель может быть без машины

public class Car {
    private Engine _engine;
    
    // Двигатель передается извне
    public Car(Engine engine) {
        _engine = engine;
    }
}

var engine = new Engine();
var car = new Car(engine);  // Машина использует существующий двигатель
```
3) **Композиция** - Объект владеет другим объектом, и зависимый объект не существует без основного.
```C#
public class Heart { }  // Сердце не существует без тела

public class Human {
    private Heart _heart;
    
    // Сердце создается при создании человека
    public Human() {
        _heart = new Heart();  // Композиция
    }
}

var human = new Human();  // Сердце создается автоматически
```

## 2. Понятие класса. Основные элементы классов. Отличия класса и объекта.

**Класс** — это шаблон или описание для создания объектов в ООП. Он определяет:

* **данные (поля, свойства)** — характеристики объекта
* **поведение (методы)** — действия, которые объект может выполнять.
* **правила доступа** (модификаторы `private`, `public` и др.).

Класс описывает **абстрактную сущность**, например, `Car`, `Person`, `Student`, а объект — это **конкретный экземпляр** этого класса (например, `myCar`, `johnDoe`).

**Основные элементы класса:**
* Поля
* Методы

**Пример класса:**
```C#
public class Person 
{
    // Поля (данные)
    private string _name;
    private int _age;

    // Конструктор (инициализация объекта)
    public Person(string name, int age) 
    {
        _name = name;
        _age = age;
    }

    // Метод (поведение)
    public void Greet() 
    {
        Console.WriteLine($"Привет, меня зовут {_name} и мне {_age} лет.");
    }
}
```
**Итог:**
* **Класс** — это шаблон с описанием структуры и поведения.
* **Объект** — конкретная "реализация" класса, созданная через `new`.
* **Основные элементы класса**: поля, методы.

## 3. Ссылочные и значимые типы данных. Примеры, объявление и инициализация переменных. Приведение ссылочных и значимых типов данных. Понтие nullable типов данных

### Ссылочные и значимые типы данных.

**Значимые типы (Value Types)**:
* Хранят непосредственно значение в стеке (stack).
* Копируются по значению (при присваивании создается копия).
* Примеры:
  * Простые типы: `int`, `float`, `double`, `bool`, `char`, `struct`, `enum`.
  * Особый случай: `decimal` (хранится как структура).

**Ссылочные типы (Reference Types)**:
* Хранят ссылку на объект в куче (heap), а сам объект — в управляемой памяти.
* Копируются по ссылке (при присваивании копируется только ссылка).
* Примеры:
  * `class`, `interface`, `string`, `object`, `dynamic`, массивы (`int[]`).
  
**Stack (стек)**
* Что хранится:
  * Значимые типы (`int`, `bool`, `struct`, `enum`).
  * Ссылки на объекты в куче (адреса).
* Особенности:
  * Быстрый доступ (как LIFO-буфер).
  * Автоматическое управление памятью (освобождается при выходе из метода).
  * Ограниченный размер (переполнение → StackOverflowException).

**Heap (куча)**
* Что хранится:
  * Объекты ссылочных типов (`class`, `string`, `массивы`)
* Особенности:
  * Динамическое выделение памяти.
  * Управляется Garbage Collector (GC) (автоматически удаляет неиспользуемые объекты).
  * Медленнее стека (из-за сложности управления).

### Примеры объявления и инициализации

**Значимые типы**
```C#
int number = 10;                  // Инициализация числа
bool isActive = true;             // Логический тип
char letter = 'A';                // Символ
DateTime date = DateTime.Now;     // Структура (значимый тип)s
```

**Ссылочные типы**
```C#
string name = "Alice";            // Строка (ссылочный)
int[] numbers = { 1, 2, 3 };      // Массив
object obj = new object();        // Базовый класс
List<int> list = new List<int>(); // Коллекция
```

### Приведение ссылочных и значимых типов данных

**Явное и неявное приведение**
```C#
// Неявное (автоматическое)
int a = 10;
double b = a;  // int → double (без потерь)

// Явное (ручное)
double c = 10.5;
int d = (int)c;  // double → int (дробная часть отбрасывается)

```

**Приведение ссылочных типов**
* Upcasting (Восходящее приведение) - преобразование производного класса к базовому (например, `Dog` → `Animal`).
  *  ✅ Безопасное (компилятор всегда разрешает).
  *  ✅ Не требует явного приведения (можно без (тип)).
  *  ✅ Происходит автоматически при присваивании.

```C#
class Animal { }
class Dog : Animal { }

Dog dog = new Dog();
Animal animal = dog;  // Upcasting (Dog → Animal)
```

* Downcasting (Нисходящее приведение) - преобразование базового класса к производному (например, Animal → Dog).
  * ⚠ Опасное (может вызвать `InvalidCastException`)
  * ⚠ Требует явного приведения (нужен оператор `(тип)`)
  * ⚠ Требует проверки (через `is`, `as` или `pattern matching`).
  
```C#
// Опасный способ
Animal animal = new Dog();
Dog dog = (Dog)animal;  // Явное приведение (работает, т.к. animal на самом деле Dog)

// Ошибка (InvalidCastException)
Animal animal = new Animal();
Dog dog = (Dog)animal;  // Ошибка! animal не является Dog
```

```C#
// Безопасные способы Downcasting
// Оператор is (проверка типа)
if (animal is Dog) 
{
    Dog dog = (Dog)animal;
    // или через pattern matching:
    if (animal is Dog dog) { ... }
}

// Оператор as (приведение с null)
Dog dog = animal as Dog;  // Если не получится — вернет null
if (dog != null) 
{
    // Приведение успешно
}

// Pattern Matching (C# 7.0+)
if (animal is Dog dog) 
{
    // dog уже приведен к типу Dog
    dog.Bark();
}
```


### Nullable-типы
**Nullable-типы** позволяют значимым типам (value types) принимать значение `null`, что невозможно в обычных условиях
* Используются, когда переменная может отсутствовать (например, данные из БД, опциональные параметры)
* Обозначаются символом ? или через структуру Nullable<T>.

```C#
int? nullableInt = null;          // Эквивалентно Nullable<int>
bool? isDone = null;              // Nullable<bool>

// Проверка и получение значения
if (nullableInt.HasValue) {
    int value = nullableInt.Value;  // Безопасное извлечение
}
// Или с оператором ?? (значение по умолчанию)
int result = nullableInt ?? 0;      // Если null, вернет 0
```

## 4. Модификаторы доступа к элементам класса. Конструктор и финализатор. Насаледование конструкторов и финализаторов. Ключевые слова base и this 

### Модификаторы доступа к элементам класса
Модификаторы доступа определяют видимость членов класса (полей, методов, свойств) для других частей программы.


| Модификатор | Доступность |
|---|---|
| `public` | Доступен всем (из любого кода). |
| `private` | Только внутри класса (по умолчанию для полей). |
| `protected` | Класс + наследники. |
| `internal` | Доступен в пределах сборки (проекта). |
| `protected internal` | Класс + наследники + вся сборка. |
| `private protected` | Только внутри класса и наследников в той же сборке. | 

### Конструктор и финализатор

**Конструктор:**
* Специальный метод, вызываемый при создании объекта (new).
* Имя совпадает с именем класса.
* Не имеет возвращаемого типа.

```C#
class Car 
{
    public string Model { get; }
    
    // Конструктор по умолчанию (если не указан)
    public Car() { Model = "Unknown"; }  
    
    // Параметризированный конструктор
    public Car(string model) => Model = model;
}

var car1 = new Car();         // Model = "Unknown"
var car2 = new Car("Tesla");  // Model = "Tesla"
```
**Финализатор:**
* Аналог деструктора в C++.
* Вызывается сборщиком мусора (GC) перед удалением объекта.
* Нельзя вызывать вручную.

```C#
class ResourceHolder 
{
    `ResourceHolder()  // Финализатор
    {
        Console.WriteLine("Финализатор вызван!");
    }
}
```

### Наследование конструкторов и финализаторов

* **Наследование конструкторов**
  * Конструкторы **не наследуются**, но можно вызывать конструктор родителя через `base`. 
  * Если базовый класс не имеет конструктора по умолчанию, производный класс **обязан** вызвать один из его конструкторов.

```C#
class Animal 
{
    public string Name { get; }
    public Animal(string name) => Name = name;
}

class Dog : Animal 
{
    public int Age { get; }
    
    // Вызов конструктора Animal через base
    public Dog(string name, int age) : base(name) 
    {
        Age = age;
    }
}

var dog = new Dog("Rex", 3);  // Name = "Rex", Age = 3
```

**Наследование финализаторов:**
* Финализаторы не наследуются, но GC автоматически вызывает цепочку финализаторов (от потомка к родителю).

### Ключевые слова `base` и `this`

**`base`:**
* Обращение к членам базового класса.
* Используется для:
  * Вызова конструктора родителя (`base()`).
  * Доступа к переопределенным методам/свойствам (`base.Method()`).

```C#
class Animal 
{
    public virtual void Eat() => Console.WriteLine("Animal eats");
}

class Dog : Animal 
{
    public override void Eat() 
    {
        base.Eat();                 // Вызов метода родителя
        Console.WriteLine("Dog eats meat");
    }
}
```


**`this`:**
* Обращение к текущему экземпляру класса.
* Используется для:
  * Устранения неоднозначности (если параметр метода совпадает с полем).
  * Вызова другого конструктора в том же классе (`this()`).

```C#
class Person 
{
    private string _name;
    
    public Person() : this("Unknown") { }  // Вызов другого конструктора
    
    public Person(string name) 
    {
        _name = name;  // Можно без this, но так понятнее:
        this._name = name;
    }
}
```

## 5. Использование ключевого слова static. Что означает модификатор static при применении к классу, полу/свойству, конструктору/финализатору. Где в памяти располагаются статические поля? 

Модификатор `static` означает, что член класса (поле, метод, свойство и т. д.) **принадлежит самому классу**, а не его экземплярам. Это позволяет использовать его без создания объекта.

### Применение static к разным элементам
1. **Статический класс (static class)**
   * Нельзя создать экземпляр (new запрещен).
   * Содержит только статические члены.
   * Используется для утилитарных функций (например, `Math`, `Console`).
```C#
public static class MathUtils 
{
    public static double Pi => 3.14159;
    public static int Add(int a, int b) => a + b;
}

// Использование без создания объекта
double pi = MathUtils.Pi;
int sum = MathUtils.Add(5, 3);
```
2. **Статическое поле/свойство (static field/property)**
   * Общее для всех экземпляров класса (хранится в одном месте памяти).
   * Инициализируется при первом обращении или в статическом конструкторе.
```C#
public class Counter 
{
    public static int TotalCount { get; private set; }  // Статическое свойство
    public int InstanceCount { get; set; }              // Обычное свойство

    public Counter() 
    {
        TotalCount++;  // Увеличиваем общий счетчик при создании объекта
        InstanceCount = 1;
    }
}

var c1 = new Counter();  // TotalCount = 1
var c2 = new Counter();  // TotalCount = 2
Console.WriteLine(Counter.TotalCount);  // 2 (доступ через класс)
```
3. **Статический метод (`static method`)**
   * Вызывается без создания объекта.

   * Не может обращаться к нестатическим полям/методам (только к статическим).
```C#
public class Logger 
{
    public static void Log(string message) 
    {
        Console.WriteLine($"[LOG] {DateTime.Now}: {message}");
    }
}

Logger.Log("Hello!");  // Вызов без new Logger()
```

4. **Статический конструктор (`static constructor`)**
   * Вызывается автоматически перед первым использованием класса.
   * Не имеет модификаторов доступа и параметров
   * Используется для инициализации статических полей.
```C#
public class Config 
{
    public static string AppName { get; }

    static Config() 
    {
        AppName = "MyApp";
        Console.WriteLine("Статический конструктор вызван!");
    }
}

// При первом обращении к Config сработает статический конструктор
Console.WriteLine(Config.AppName);  // "MyApp"
```
5. **Cтатический финализатор**
   * В C# **не существует** статических финализаторов.
   * Финализаторы (деструкторы) всегда связаны с экземплярами класса.

### Где в памяти располагаются статические поля? 
* Статические поля хранятся в **специальной области памяти** — High Frequency Heap (часть кучи, управляемой CLR).
* Отличия от обычных полей:

|**Характеристика**|**Обычные поля**|**Статические поля**|
|---|---|---|
|**Память**|В куче (heap) для каждого объекта|В High Frequency Heap|
|**Время жизни**|Удаляются при сборке мусора (GC)|Существуют до завершения программы|
|**Доступ**|Через экземпляр (`obj.Field`)|Через класс (`Class.Field`)|

### Когда использовать static?
* ✅ Для общих ресурсов (например, кэш, конфигурация).
* ✅ Для утилитарных методов (например, Math.Sqrt).
* ✅ Для реализации паттернов (Singleton, Factory).
### Когда НЕ использовать static?
* ❌ Если состояние должно быть уникальным для каждого объекта.
* ❌ Для полей, которые могут изменяться в многопоточной среде (без синхронизации).

## 6. Использование ThreadStatic / AsyncLocal. Взаимодействие static с потоками

[[[[[[[[[ Пока пропущено ]]]]]]]]]


## 7. Использование абстрактных классов и методов. Инициализация переменных типа абстрактного класса, создание объектов абстрактного класса. Наследование абстрактных классов. Отличие от виртуальных методов и обычных методов

Абстрактные классы и методы используются для создания **базового шаблона**, который **нельзя использовать напрямую**, но **можно наследовать и реализовывать** в производных классах.

### Абстрактный класс (abstract class)
* Нельзя создать экземпляр (new запрещен).
* Может содержать:
  * Абстрактные методы (без реализации).
  * Обычные методы (с реализацией).
  * Поля, свойства, конструкторы.

**Пример:**
```C#
public abstract class Animal 
{
    public string Name { get; set; }  // Обычное свойство
    
    public abstract void MakeSound();  // Абстрактный метод (без реализации, должен быть реализован наследником)
    
    public void Eat()                 // Обычный метод (с реализацией)
    {
        Console.WriteLine($"{Name} ест.");
    }
}
```

### Абстрактный метод (abstract method)
* Не имеет тела (только сигнатура).
* Должен быть переопределен в производном классе (кроме abstract class).

**Пример:**
```C#
// Наследуем из предыдущего примера 
public class Dog : Animal 
{
    public override void MakeSound()  // Обязательная реализация
    {
        Console.WriteLine("Гав!");
    }
}
```

### Инициализация переменных типа абстрактного класса
* Хотя нельзя создать объект абстрактного класса, можно:    
  * Создать переменную этого типа.
  * Присвоить ей экземпляр конкретного (не абстрактного) наследника.

**Пример:**
```C#
Animal animal = new Dog { Name = "Рекс" };  // OK: Dog — не абстрактный
animal.MakeSound();  // Гав!
animal.Eat();        // Рекс ест.
```

### Наследование абстрактных классов
* Абстрактный класс может наследовать другой абстрактный класс.
* Если класс-наследник не реализует все абстрактные методы, он тоже должен быть `abstract`
```C#
public abstract class Mammal : Animal 
{
    public abstract void Run();  // Новый абстрактный метод
}

public class Cat : Mammal 
{
    public override void MakeSound() => Console.WriteLine("Мяу!");
    public override void Run() => Console.WriteLine("Бежит!");
}
```

### Отличие абстрактного от виртуальных методов и обычных **методов**

**Виртуальный метод (`virtual`)** — это метод в базовом классе, который:
* Имеет реализацию (тело метода).
* Может быть переопределен в производных классах (с помощью `override`).
* Не является обязательным для переопределения (в отличие от `abstract`).

|Характеристика|Обычный метод|Виртуальный метод|Абстрактный метод|
|---|---|---|---|
|Реализация|Есть (тело метода)|Есть (можно переопределить)|Нет (только сигнатура)|
|Переопределение|❌ Нет|✅ Да (`override`)|✅ Да (`override`)
|Где используется|Любой класс|Любой класс|	Только в `abstract class`|
|Обязательность|Не требует переопределения|Не требует переопределения|Требует в неабстрактном наследнике


### Ключевые отличия абстрактных **классов** от **интерфейсов**
**Интерфейс (`interface`)** — это контракт, который определяет какие методы, свойства и события должен реализовать класс или структура. Он описывает что должно быть сделано, но не как это реализовано.

|Критерий|Абстрактный класс|Интерфейс 
|---|---|---|
|Реализация|Может содержать код|Только сигнатуры методов
|Наследование|Одиночное (`class A : B`)|Множественное (`class A : I1, I2`)
|Поля/Свойства|Могут быть|Только `auto-properties` (C# 8+) (хз че это)
|Конструкторы|Могут быть|Не могут``


### Итог
* **Абстрактный класс** — это "недоделанный" класс, требующий реализации в наследниках.

* **Абстрактный метод** — метод без реализации, который обязан быть переопределен.


## 8. Использование виртуальных методов. Переопределение методов и операторов. Отличие от абстрактных методов и обычных методов
**Виртуальные методы (`virtual`)** позволяют изменять поведение методов в производных классах без потери базовой реализации

**Виртуальный метод (`virtual`)** — это метод в базовом классе, который:
* Объявляются в базовом классе с ключевым словом `virtual`.
* Имеет реализацию по умолчанию (тело метода).
* Может быть переопределен в производных классах (с помощью `override`).
* Не является обязательным для переопределения (в отличие от `abstract`).

**Пример:**
```C#
class Animal 
{
    public virtual void MakeSound() 
    {
        Console.WriteLine("Some sound");
    }
}

class Dog : Animal 
{
    public override void MakeSound() 
    {
        Console.WriteLine("Гав!");
    }
}

Animal animal = new Dog();
animal.MakeSound();  // "Гав!" (вызывается переопределенный метод) 
```

### Переопределение методов (`override`)
* Используется для замены реализации виртуального или абстрактного метода.
* Требует, чтобы базовый метод был помечен как `virtual`, `abstract` или `override`.

**Пример с цепочкой наследования:**
```C#
class Animal 
{
    public virtual void MakeSound() 
    {
        Console.WriteLine("Some sound");
    }
}

class Bird : Animal 
{
    public override void MakeSound() 
    {
        Console.WriteLine("Чирик!");
    }
}

class Parrot : Bird 
{
    public override void MakeSound() 
    {
        base.MakeSound();  // Вызов метода родителя ("Чирик!")
        Console.WriteLine("Попка дурак!");
    }
}

var parrot = new Parrot();
parrot.MakeSound();  
// Вывод:
// Чирик!
// Попка дурак!
```

### Переопределение операторов (operator)

C# позволяет переопределять стандартные операторы (`+`, `-`, `==` и др.) для своих классов.

**Пример перегрузки оператора +:**
```C#
class Point 
{
    public int X { get; set; }
    public int Y { get; set; }

    public static Point operator +(Point a, Point b) 
    {
        return new Point { X = a.X + b.X, Y = a.Y + b.Y };
    }
}

var p1 = new Point { X = 1, Y = 2 };
var p2 = new Point { X = 3, Y = 4 };
var result = p1 + p2;  // X=4, Y=6
```
**Какие операторы можно перегружать?**
* Унарные: `+`, `-`, `!`, `++`, `--`
* Бинарные: `+`, `-`, `*`, `/`, `==`, `!=`, `>`, `<` и др.
* Нельзя перегружать: `&&`, `||`, `=`, `.`, ``` ` ```

### Отличие  виртуальных методов от абстрактного метода и обычных **методов**

|Характеристика|Обычный метод|Виртуальный метод|Абстрактный метод|
|---|---|---|---|
|Реализация|Есть (тело метода)|Есть (можно переопределить)|Нет (только сигнатура)|
|Переопределение|❌ Нет|✅ Да (`override`)|✅ Да (`override`)
|Где используется|Любой класс|Любой класс|	Только в `abstract class`|
|Обязательность|Не требует переопределения|Не требует переопределения|Требует в неабстрактном наследнике


## 9. Понятие интерфейсов и их использование. Интерфейсные ссылки. Отличие интерфейсов от абстрактных классов. Понятие ковариантности и контрвариантности интерфейсов. 
### Понятие интерфейсов и их использование
**Интерфейс (   `interface`)** – это контракт, который определяет набор методов, свойств, событий или индексаторов, которые должны быть реализованы в классе. Интерфейс не содержит реализации (до C# 8.0), только сигнатуры.

**Основные особенности:**
* Класс, реализующий интерфейс, обязан предоставить реализацию всех его членов.
* Позволяет достичь множественного наследования (класс может реализовывать несколько интерфейсов).
* Используется для абстрагирования поведения и обеспечения гибкости в проектировании кода.

**Пример:**
```csharp
public interface ILogger {
    void Log(string message);
}

public class ConsoleLogger : ILogger {
    public void Log(string message) => Console.WriteLine(message);
}
```

### Интерфейсные ссылки
**Интерфейсная ссылка** — это переменная, объявленная как тип интерфейса, которая может ссылаться на экземпляр любого класса, реализующего этот интерфейс.
Преимущества:
* Полиморфизм : работа с объектами через общий интерфейс.
* Тестируемость : упрощает замену реализаций (например, заглушки в тестах).

Пример:
```C#
ILogger logger = new ConsoleLogger(); // Интерфейсная ссылка
logger.Log("Hello!");
```

|Критерий |Интерфейсы|Абстрактные классы|
|---|---|---|
Реализация|Не содержат реализации (кроме C# 8.0+).|Могут содержать реализацию методов.
Множественное наследование|Поддерживается (класс реализует несколько интерфейсов).|Не поддерживается (класс наследует только один класс).
Поля| Не могут содержать полей.|Могут содержать поля.
Конструкторы|Не имеют конструкторов.|Имеют конструкторы.
Модификаторы доступа|Все члены неявно `public`.|Могут иметь разные модификаторы.
Цель|Определяют поведение.|Определяют состояние и поведение.

Пример абстрактного класcа:
```c#
public abstract class Animal {
    public abstract void MakeSound();
}
```
### Ковариантность и контрвариантность интерфейсов

Эти механизмы работают с обобщениями (`generics`) и позволяют безопасно преобразовывать типы.

1) Ковариантность (`out`):

    Разрешает использовать **более специфичный тип** , чем указан в интерфейсе. Применяется, когда тип используется **только как возвращаемое значение .**
    
    Пример:
    ```C#
    public interface IEnumerable<out T> {
        IEnumerator<T> GetEnumerator();
    }

    IEnumerable<string> strings = new List<string>();
    IEnumerable<object> objects = strings; // Ковариантность: string → object
    ```

2) Контрвариантность (in):
    
    Разрешает использовать **более общий тип** , чем указан в интерфейсе. Применяется, когда тип используется **только как параметр метода**.

    Пример:

    ```C#
    public interface IComparer<in T> {
        int Compare(T x, T y);
    }

    IComparer<object> comparer = new MyComparer();
    IComparer<string> stringComparer = comparer; // Контрвариантность: object ← string
    ```

Ограничения:
* Работает только с ссылочными типами (не с int, DateTime и т.д.).  
### Итог
* Интерфейсы фокусируются на поведении и поддерживают множественное наследование.
* Абстрактные классы предоставляют реализацию и состояние, но ограничены одиночным наследованием.
* Ковариантность/контрвариантность упрощают работу с обобщениями, обеспечивая гибкость типов.

## 10. Генерация исключений и их обработка. Блоки обработки исключений. Генерация собственных типов исключений. Обработка исключений при многопоточном/асинхронном программировании

### Генерация исключений и их обработка

**Исключения** — это механизм, позволяющий обрабатывать ошибки и нештатные ситуации в программе.

**Генерация исключения: **  
* спользуется ключевое слово `throw`.
* Может быть выброшено как системное исключение (`Exception`), так и пользовательское.

**Пример генерации исключения:**
```C#
if (value < 0)
    throw new ArgumentException("Значение не может быть отрицательным.");
```

### Блоки обработки исключений

Для обработки исключений используются блоки:
* `try` : код, в котором может произойти ошибка.
* `catch` : обработка исключения.
* `finally` : код, выполняющийся всегда (например, освобождение ресурсов).


```C#
try {
    int result = Divide(10, 0);
} catch (DivideByZeroException ex) {
    Console.WriteLine($"Ошибка: {ex.Message}");
} finally {
    Console.WriteLine("Блок finally выполнен.");
}
```

Особенности:
* Фильтры исключений (`when`):

    ```C#
    catch (Exception ex) when (ex.Message.Contains("деление")) {
        Console.WriteLine("Конкретная ошибка деления.");
    }
    ```
* Вложенные блоки
    ```c#
    try {
        // Внешний try
        try { /* Внутренний try */ }
        catch { /* Внутренний catch */ }
    } catch { /* Внешний catch */ }
    ```

### Генерация собственных типов исключений
Для создания пользовательских исключений:
* Наследуйтесь от `Exception` или его подклассов (например, `ArgumentException`).
* Реализуйте обязательные конструкторы:
  * `public MyException() : base()`
  * `public MyException(string message) : base(message)`
  * `public MyException(string message, Exception innerException) : base(message, innerException)`
Пример:

```C#
public class InvalidAgeException : Exception {
    public InvalidAgeException() : base("Некорректный возраст.") {}
    public InvalidAgeException(string message) : base(message) {}
    public InvalidAgeException(string message, Exception inner) : base(message, inner) {}
}

// Использование
if (age < 0)
    throw new InvalidAgeException("Возраст не может быть отрицательным.");
```

### Обработка исключений в многопоточном/асинхронном программировании

**Многопоточность (Thread)**
* Исключения в потоке **не перехватываются** в основном потоке.
* Используйте `try-catch` внутри метода потока:

    ```C#
    Thread thread = new Thread(() => {
        try {
            // Код с возможной ошибкой
        } catch (Exception ex) {
            Console.WriteLine($"Ошибка в потоке: {ex.Message}");
        }
    });
    thread.Start();
    ```

**Задачи (Task)**
* Исключения оборачиваются в `AggregateException`.
* Используйте `await` для автоматического распаковывания:
    ```C#
    try {
        await Task.Run(() => {
            throw new InvalidOperationException("Ошибка задачи.");
        });
    } catch (InvalidOperationException ex) {
        Console.WriteLine($"Ошибка: {ex.Message}");
    }
    ```

**Асинхронный код (async/await)**
* Исключения перебрасываются в точку вызова `await`.
* Пример: 
```C#
async Task MyMethodAsync() {
    throw new IOException("Ошибка ввода-вывода.");
}

try {
    await MyMethodAsync();
} catch (IOException ex) {
    Console.WriteLine($"Ошибка: {ex.Message}");
}
```

**Обработка нескольких исключений**
* Используйте `AggregateException` для работы с несколькими ошибками
* Пример:
```С#
try {
    var task1 = Task.Run(() => throw new Exception("Ошибка 1"));
    var task2 = Task.Run(() => throw new Exception("Ошибка 2"));
    Task.WaitAll(task1, task2);
} catch (AggregateException aex) {
    foreach (var ex in aex.InnerExceptions)
        Console.WriteLine($"Ошибка: {ex.Message}");
}
```


## 11. Обобщенные типы данных. Наследование обобщенных типов данных. Ограничения, накладываемые на использование типов данных в обобщенных типах данных. Отличия от boxing/unboxing

### Обобщенные типы данных (Generics)

**Обобщенные типы** — это шаблоны, позволяющие создавать классы, интерфейсы и методы с параметром типа , который определяется при использовании.

**Преимущества:**
* Типобезопасность : ошибки выявляются на этапе компиляции.
* Производительность : избегается упаковка/распаковка (boxing/unboxing).
* Гибкость : один код работает с разными типами.

**Пример:**
```C#
public class Box<T> {
    private T _value;
    public void Set(T value) => _value = value;
    public T Get() => _value;
}

// Использование:
Box<int> intBox = new Box<int>();
intBox.Set(42);
int number = intBox.Get(); // Без cast
```

### Наследование обобщенных типов
Обобщенные типы могут наследовать как от обобщенных, так и от необобщенных классов/интерфейсов.

**Правила наследования:**
* Обобщенный класс → обобщенный класс:
    ```C#
    public class Base<T> { /* ... */ }
    public class Derived<T> : Base<T> { /* ... */ }
    ```
* Обобщенный класс → конкретный класс:
    ```C#
    public class Derived : Base<string> { /* ... */ } // Base фиксируется к string
    ```
* Конкретный класс → обобщенный класс:
    ```C#
    public class Base { /* ... */ }
    public class Derived<T> : Base { /* ... */ }
    ```

**Пример наследования с параметрами:**
```C#
public class Animal { /* Базовый класс */ }
public class Cat : Animal { /* Наследник */ }

public class Cage<T> where T : Animal {
    public T CurrentAnimal { get; set; }
}

public class CatCage : Cage<Cat> {
    // Может работать только с Cat
}
```

### Ограничения на типы в обобщениях
Ограничения (`constraints`) задают правила для параметров типа, чтобы гарантировать доступность методов, свойств или поведения.

**Типы ограничений:**
|Ограничение|Описание|
|---|---|
|`where T : class`|T должен быть ссылочным типом (класс, интерфейс, делегат).|
|`where T : struct`|T должен быть значимым типом `int`, `DateTime`, собственные `struct`.|
|`where T : new()`|T должен иметь конструктор без параметров.|
|`where T : <base class>`|T должен наследовать указанный базовый класс. |
|`where T : <interface>`|T должен реализовать указанный интерфейс.|
|`where T : U`|T должен быть или наследовать тип U.|


**Примеры использования:**
```C#
public class Repository<T> where T : class, IEntity, new() {
    public T Create() {
        T item = new T(); // new() позволяет создать экземпляр
        return item;
    }
}
```

**Комбинация ограничений:**
```C#
public class Processor<T> where T : class, IComparable<T>, new() {
    // T должен быть ссылочным типом, реализовать IComparable<T> и иметь конструктор
}
```


### Отличие от boxing/unboxing
**Boxing/unboxing** — это процесс упаковки и распаковки значимых типов (`int`, `bool`, `DateTime`) в/из ссылочного типа `object`.

**Boxing (упаковка):**
```C#
int number = 42;
object obj = number; // Boxing: int → object
```

**Unboxing (распаковка):**
```C#
object obj = 42;
int number = (int)obj; // Unboxing: object → int
```

**Проблемы boxing/unboxing:**
* Производительность : дополнительные операции копирования.
* Ошибка времени выполнения : если тип не совпадает.

**Как обобщения решают эти проблемы?**
* Обобщения работают с конкретными типами , избегая преобразования в object.
* Пример:
```C#
// С использованием object (boxing/unboxing)
List<object> list = new List<object>();
list.Add(1); // Boxing
int number = (int)list[0]; // Unboxing

// С обобщением
List<int> list = new List<int>();
list.Add(1); // Без boxing
int number = list[0]; // Без cast
```

## 12. Массивы и коллекции. Инициализация и использование. Отличия Array от List<T>. Преимущества использования Dictionary<TKey, TValue> ? 

### Массивы и коллекции: инициализация и использование
**Массивы** (`Array`) и **коллекции** (`List<T>`, `Dictionary<TKey, TValue>`) — это структуры данных для хранения элементов. Они отличаются по гибкости, производительности и функциональности.

**Массив (`Array`)** — это статическая коллекция, которая хранит элементы фиксированного размера одного типа.

```C#
// Пример 1: Объявление и инициализация
int[] numbers = new int[5]; // Массив из 5 элементов
numbers[0] = 10;

// Пример 2: Инициализатор
string[] names = { "Alice", "Bob" };

// Пример 3: Многомерный массив
int[,] matrix = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };
```

**Особенности:**

* Индексация начинается с `0`.
* Размер массива неизменен после создания.
* Эффективен для чтения по индексу (время `O(1)`).
* Для изменения размера требуется создать новый массив и скопировать элементы:
    ```C#
    Array.Resize(ref numbers, 10); // Создает новый массив из 10 элементов
    ```

**Коллекции (`List<T>`)** — это динамическая коллекция, реализованная на основе массива, которая автоматически управляет размером.

```C#
// Пример 1: Пустой список
List<int> numbers = new List<int>();

// Пример 2: Инициализатор коллекции
List<string> names = new List<string> { "Alice", "Bob" };

// Пример 3: Указание начальной емкости (оптимизация)
List<int> largeList = new List<int>(1000); // Емкость = 1000
```

**Операции:**
```C#
// Добавление элементов
numbers.Add(42);
numbers.AddRange(new int[] { 1, 2, 3 });

// Удаление элементов
numbers.Remove(42); // Удаление по значению
numbers.RemoveAt(0); // Удаление по индексу

// Поиск и проверка
bool exists = numbers.Contains(42);
int index = numbers.IndexOf(42);
```

**Особенности:**
* Динамическое изменение размера (автоматическое увеличение массива).
* Поддержка LINQ и методов `IEnumerable<T>`.
* Меньше кода для управления размером по сравнению с массивами.

### Отличия `Array` от `List<T>`

|Критерии|Масиив `Array`|Список `List<T>`|
|---|---|---|
|Размер|Фиксированный|Фиксированный
|Изменение размера|	Требует копирования в новый массив|Автоматическое управление
|Методы|Минимальный набор (Length, Rank, SetValue)|Богатый набор (Add, Remove, Find, Sort)
|Производительность|Быстрый доступ по индексу (O(1))|Немного медленнее (за счет динамики)
|Типобезопасность|Нет (работает с object в необобщенных версиях)|Полностью типобезопасен
|Совместимость|Универсальная (поддержка в старых API)|Требует .NET 2.0+
|Память|Меньше накладных расходов|Немного больше (за счет динамической емкости)

### Преимущества `Dictionary<TKey, TValue>`
`Dictionary<TKey, TValue>` — это коллекция пар ключ-значение, где ключ уникаен , а доступ к элементам осуществляется за O(1) благодаря хэшированию.

```C#
// Пример 1: Обычная инициализация
Dictionary<string, int> ages = new Dictionary<string, int>();
ages["Alice"] = 30;
ages.Add("Bob", 25);

// Пример 2: Инициализатор коллекции
Dictionary<int, string> codes = new Dictionary<int, string> {
    { 1, "One" },
    { 2, "Two" }
};
```

**Операции:**
```C#
// Добавление элементов
ages.Add("Charlie", 40);
// Проверка наличия ключа
if (ages.ContainsKey("Alice")) { /* ... */ }
// Получение значения
if (ages.TryGetValue("Alice", out int age)) {
    Console.WriteLine(age);
}
// Удаление
ages.Remove("Bob");
```

**Преимущества:**
* Быстрый поиск по ключу (O(1)).
* Гибкость в выборе типа ключа (например, строки, объекты, пользовательские типы).
Ч* итаемость кода : логика работы с данными становится более понятной (например, `user.Password` вместо `users[2]`).

**Ограничения:**
* Порядок элементов не гарантирован (в отличие от `SortedDictionary<TKey, TValue>` или `OrderedDictionary`).
* Требуется корректная реализация `GetHashCode()` и `Equals()` для пользовательских типов ключей.
```C#
// Хранение настроек пользователя
Dictionary<string, object> settings = new Dictionary<string, object> {
    { "Theme", "Dark" },
    { "FontSize", 14 }
};

// Получение значения
if (settings.TryGetValue("Theme", out object theme)) {
    Console.WriteLine($"Текущая тема: {theme}");
}
```

### Рекомендации по использованию
* Используйте `Array` , если:
  * Размер коллекции известен заранее и не меняется.
  * Критична производительность (например, в циклах).
* Используйте `List<T>`, если:
  * Коллекция динамически изменяется.
  * Нужны методы Add, Remove, Find и т.д.
  * Требуется работа с LINQ.
* Используйте `Dictionary<TKey, TValue>`, если:
  * Нужен быстрый доступ к данным по ключу.
  * Ключи уникальны (например, идентификаторы, имена настроек).

### Итог
* Массивы (`Array`) — это простые и быстрые структуры для работы с фиксированным набором данных.
* Списки (`List<T>`) — более гибкая альтернатива массивам с динамическим управлением размера и богатым API.
* Словари (`Dictionary<TKey, TValue>`) — идеальный выбор для хранения данных с уникальными ключами и быстрым доступом.

## 13. Делегаты. Определение, объявление и вызов делегатов. Встроенные делегаты Action\Func\Predicate. Отличия от событий.

### Делегаты: определение, объявление и вызов
**Делегат** — это **тип** , представляющий ссылку на метод с определенной сигнатурой. Он позволяет передавать методы как параметры , использовать их для обратных вызовов или реализации шаблонов проектирования (например, Observer).

**Объявление делегата:**
```C#
// Определение делегата
public delegate void MyDelegate(string message);

// Класс с методом, соответствующим сигнатуре делегата
public class Printer {
    public void Print(string text) => Console.WriteLine(text);
}
```

**Создание и вызов делегата**
```C#
Printer printer = new Printer();
MyDelegate del = new MyDelegate(printer.Print); // Создание делегата
del("Hello, world!"); // Вызов делегата
```

**Мульткаст (цепочка делегатов):**
```C#
MyDelegate del1 = printer.Print;
MyDelegate del2 = Console.WriteLine;

MyDelegate multiDel = del1 + del2; // Объединение делегатов
multiDel("Message"); // Вызов обоих методов
```

### Встроенные делегаты: `Action`, `Func`, `Predicate`

`Action<T>` - Представляет метод, не возвращающий значение и принимающий один или несколько параметров .
```C#
Action<string> logAction = Console.WriteLine;
logAction("Logging message");
```

`Func<T, TResult>` - Представляет метод, возвращающий значение и принимающий один или несколько параметров.

```C#
Func<int, int, int> add = (a, b) => a + b;
int result = add(3, 5); // 8
```

`Predicate<T>` - Устаревший, но часто используется для проверок. Возвращает `bool` и принимает один параметр.

```C#
Predicate<int> isEven = x => x % 2 == 0;
bool even = isEven(4); // true
```

**Преимущества встроенных делегатов:**

* Не нужно создавать собственные делегаты для стандартных сценариев.
* Поддержка лямбд и анонимных методов.
* Используются в LINQ, коллекциях и асинхронном программировании.

## 14. События\Event. Определение, объявление и вызов событий. Методы Add и Remove. Отличия от делегатов

### Определение событий
**Событие (`event`)** — это механизм, позволяющий классу уведомлять другие части программы о наступлении какого-либо действия (например, клик мыши, завершение загрузки файла). События строятся на основе делегатов , но добавляют ограничения для обеспечения безопасности и инкапсуляции.

Пример использования:
* Уведомления о действиях в UI (например, нажатие кнопки).
* Реакция на изменения состояния объекта (например, обновление данных).

### Объявление и вызов событий
**Шаг 1: Объявление события**
```C#
public class Button {
    // Объявление события с использованием стандартного делегата EventHandler
    public event EventHandler Click;
}
```
* `EventHandler` : стандартный делегат, принимающий два параметра:
* `object sender` — ссылка на объект, вызвавший событие.
* `EventArgs e` — данные события (может быть пустым, если данные не нужны).

**Шаг 2: Вызов события**
Для вызова события создается метод `On...` (по соглашению), который проверяет наличие подписчиков и вызывает событие:

```C#
public class Button {
    public event EventHandler Click;

    // Метод для вызова события
    public void OnClick() {
        // Проверка на null и вызов события
        Click?.Invoke(this, EventArgs.Empty);
    }
}
```

**Шаг 3: Подписка на событие**
```C#
Button button = new Button();

// Подписка на событие с помощью лямбда-выражения
button.Click += (sender, e) => Console.WriteLine("Кнопка нажата!");

// Вызов метода, который инициирует событие
button.OnClick(); // Выведет: "Кнопка нажата!"
```

### Методы Add и Remove для событий

По умолчанию события управляются через опера    торы `+=` и `-=`. Однако можно явно определить методы `add` и `remove` , чтобы добавить логику при подписке/отписке

**Пример с кастомными методами add/remove:**
```C#
public class Button {
    private EventHandler _clickHandler;

    public event EventHandler Click {
        add {
            Console.WriteLine("Подписка на событие");
            _clickHandler += value;
        }
        remove {
            Console.WriteLine("Отписка от события");
            _clickHandler -= value;
        }
    }

    public void OnClick() {
        _clickHandler?.Invoke(this, EventArgs.Empty);
    }
}

// Использование
Button button = new Button();

button.Click += (s, e) => Console.WriteLine("Обработчик 1");
button.Click += (s, e) => Console.WriteLine("Обработчик 2");

button.OnClick(); // Вызов всех подписчиков

button.Click -= (s, e) => Console.WriteLine("Обработчик 2"); // Отписка
```
**Зачем это нужно?**
* Логирование подписок/отписок.
* Проверка условий перед добавлением/удалением обработчика.
* Интеграция с другими системами (например, счетчик активных подписчиков).

### Пример реального использования: событие с данными
```C#
// Создание пользовательского EventArgs
public class MouseEventArgs : EventArgs {
    public int X { get; set; }
    public int Y { get; set; }
}

// Объявление события с пользовательскими данными
public class Button {
    public event EventHandler<MouseEventArgs> Click;

    public void OnClick(int x, int y) {
        Click?.Invoke(this, new MouseEventArgs { X = x, Y = y });
    }
}

// Использование события
Button button = new Button();
button.Click += (sender, e) => {
    Console.WriteLine($"Клик по координатам: X={e.X}, Y={e.Y}");
};

button.OnClick(100, 200); // Выведет: "Клик по координатам: X=100, Y=200"
```

## 13 и 14 Общее. Отличия событий от делегатов

**Делегат** — это тип , представляющий ссылку на метод с определённой сигнатурой. Позволяет:
* Передавать методы как параметры.
* Реализовывать callback-функции.
* Использовать в LINQ, асинхронности и других сценариях.

**Событие** — это механизм , построенный на делегатах, для реализации шаблона "Издатель-Подписчик". Позволяет:
* Уведомлять объекты о наступлении действий (например, клик мыши, завершение загрузки).
* Ограничивать доступ: событие можно подписаться/отписаться , но нельзя вызвать напрямую извне класса.

|Критерий|Делегаты|События|
|---|---|---|
|Цель|Хранение ссылки на метод|Реализация шаблона "Издатель-Подписчик"|
|Доступ|Может быть вызван из любого места|Вызывается    только внутри класса, где объявлен|
|Синтаксис подписки|`+=`,`-=`|`+=`,`-=`|
|Контроль вызова|Полный контроль (можно вызвать напрямую)|Ограниченный (вызов через методы класса)|
|Пример использования|Callback-функции, LINQ, асинхронность|Обработка кликов, уведомления, события UI|

